diff --git a/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/AbstractCollectionPolicy.java b/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/AbstractCollectionPolicy.java
index 191ae8bdf87..1efa0f148d2 100644
--- a/graal/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/AbstractCollectionPolicy.java
+++ b/graal/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/AbstractCollectionPolicy.java
@@ -241,6 +241,7 @@ abstract class AbstractCollectionPolicy implements CollectionPolicy {
     }
 
     @Override
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     public UnsignedWord getSurvivorSpacesCapacity() {
         assert VMOperation.isGCInProgress() : "use only during GC";
         guaranteeSizeParametersInitialized();
@@ -288,6 +289,7 @@ abstract class AbstractCollectionPolicy implements CollectionPolicy {
     }
 
     @Override
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     public int getTenuringAge() {
         assert VMOperation.isGCInProgress() : "use only during GC";
         return tenuringThreshold;
diff --git a/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/AlignedHeapChunk.java b/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/AlignedHeapChunk.java
index bc15be90bdc..da7be2af222 100644
--- a/graal/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/AlignedHeapChunk.java
+++ b/graal/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/AlignedHeapChunk.java
@@ -83,6 +83,7 @@ public final class AlignedHeapChunk {
     public interface AlignedHeader extends HeapChunk.Header<AlignedHeader> {
     }
 
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     public static void initialize(AlignedHeader chunk, UnsignedWord chunkSize) {
         HeapChunk.initialize(chunk, AlignedHeapChunk.getObjectsStart(chunk), chunkSize);
     }
@@ -101,6 +102,7 @@ public final class AlignedHeapChunk {
     }
 
     /** Allocate uninitialized memory within this AlignedHeapChunk. */
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     static Pointer allocateMemory(AlignedHeader that, UnsignedWord size) {
         Pointer result = WordFactory.nullPointer();
         UnsignedWord available = HeapChunk.availableObjectMemory(that);
@@ -112,6 +114,14 @@ public final class AlignedHeapChunk {
         return result;
     }
 
+    /** Retract the latest allocation. */
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
+    static void retractAllocation(AlignedHeader that, UnsignedWord size) {
+        Pointer newTop = HeapChunk.getTopPointer(that).subtract(size);
+        assert newTop.aboveOrEqual(getObjectsStart(that));
+        HeapChunk.setTopPointer(that, newTop);
+    }
+
     @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     static UnsignedWord getCommittedObjectMemory(AlignedHeader that) {
         return HeapChunk.getEndOffset(that).subtract(getObjectsStartOffset());
@@ -129,6 +139,7 @@ public final class AlignedHeapChunk {
     }
 
     /** Return the offset of an object within the objects part of a chunk. */
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     public static UnsignedWord getObjectOffset(AlignedHeader that, Pointer objectPointer) {
         Pointer objectsStart = getObjectsStart(that);
         return objectPointer.subtract(objectsStart);
@@ -139,6 +150,7 @@ public final class AlignedHeapChunk {
     }
 
     @AlwaysInline("GC performance")
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     static boolean walkObjectsInline(AlignedHeader that, ObjectVisitor visitor) {
         return HeapChunk.walkObjectsFromInline(that, getObjectsStart(that), visitor);
     }
@@ -165,10 +177,5 @@ public final class AlignedHeapChunk {
         public boolean isAligned(AlignedHeapChunk.AlignedHeader heapChunk) {
             return true;
         }
-
-        @Override
-        public UnsignedWord getAllocationStart(AlignedHeapChunk.AlignedHeader heapChunk) {
-            return getObjectsStart(heapChunk);
-        }
     }
 }
diff --git a/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/AuxiliaryImageHeap.java b/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/AuxiliaryImageHeap.java
index 2d18a356ece..3ac40d5a385 100644
--- a/graal/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/AuxiliaryImageHeap.java
+++ b/graal/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/AuxiliaryImageHeap.java
@@ -48,6 +48,7 @@ public interface AuxiliaryImageHeap {
 
     boolean walkObjects(ObjectVisitor visitor);
 
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     boolean walkRegions(MemoryWalker.ImageHeapRegionVisitor visitor);
 
     ImageHeapInfo getImageHeapInfo();
diff --git a/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/BasicCollectionPolicies.java b/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/BasicCollectionPolicies.java
index c568c7b1be6..4e2b92b27a8 100644
--- a/graal/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/BasicCollectionPolicies.java
+++ b/graal/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/BasicCollectionPolicies.java
@@ -32,6 +32,7 @@ import org.graalvm.word.UnsignedWord;
 import org.graalvm.word.WordFactory;
 
 import com.oracle.svm.core.SubstrateGCOptions;
+import com.oracle.svm.core.Uninterruptible;
 import com.oracle.svm.core.heap.GCCause;
 import com.oracle.svm.core.heap.PhysicalMemory;
 import com.oracle.svm.core.heap.ReferenceAccess;
@@ -49,7 +50,7 @@ final class BasicCollectionPolicies {
     private BasicCollectionPolicies() {
     }
 
-    abstract static class BasicPolicy implements CollectionPolicy {
+    public abstract static class BasicPolicy implements CollectionPolicy {
         protected static UnsignedWord m(long bytes) {
             assert 0 <= bytes;
             return WordFactory.unsigned(bytes).multiply(1024).multiply(1024);
@@ -161,6 +162,7 @@ final class BasicCollectionPolicies {
         }
 
         @Override
+        @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
         public UnsignedWord getSurvivorSpacesCapacity() {
             return WordFactory.zero();
         }
@@ -196,6 +198,7 @@ final class BasicCollectionPolicies {
         }
 
         @Override
+        @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
         public int getTenuringAge() {
             return 1;
         }
diff --git a/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/ChunksAccounting.java b/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/ChunksAccounting.java
index 17c24b57683..68c036cb640 100644
--- a/graal/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/ChunksAccounting.java
+++ b/graal/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/ChunksAccounting.java
@@ -54,12 +54,14 @@ final class ChunksAccounting {
         reset();
     }
 
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     public void reset() {
         alignedCount = 0L;
         unalignedCount = 0L;
         unalignedChunkBytes = WordFactory.zero();
     }
 
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     public UnsignedWord getChunkBytes() {
         return getAlignedChunkBytes().add(getUnalignedChunkBytes());
     }
@@ -96,6 +98,7 @@ final class ChunksAccounting {
         }
     }
 
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     void unnoteAlignedHeapChunk() {
         alignedCount--;
         if (parent != null) {
@@ -117,10 +120,12 @@ final class ChunksAccounting {
         }
     }
 
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     void unnoteUnalignedHeapChunk(UnalignedHeapChunk.UnalignedHeader chunk) {
         unnoteUnaligned(UnalignedHeapChunk.getCommittedObjectMemory(chunk));
     }
 
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     private void unnoteUnaligned(UnsignedWord size) {
         unalignedCount--;
         unalignedChunkBytes = unalignedChunkBytes.subtract(size);
diff --git a/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/CollectionPolicy.java b/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/CollectionPolicy.java
index 1d11025ef0f..ba738c3df22 100644
--- a/graal/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/CollectionPolicy.java
+++ b/graal/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/CollectionPolicy.java
@@ -30,6 +30,7 @@ import org.graalvm.word.UnsignedWord;
 import org.graalvm.word.WordFactory;
 
 import com.oracle.svm.core.SubstrateOptions;
+import com.oracle.svm.core.Uninterruptible;
 import com.oracle.svm.core.heap.GCCause;
 import com.oracle.svm.core.heap.PhysicalMemory;
 import com.oracle.svm.core.util.UserError;
@@ -176,6 +177,7 @@ public interface CollectionPolicy {
      * survivor-to spaces of all ages. In other words, when copying during a collection, up to 2x
      * this amount can be used for surviving objects.
      */
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     UnsignedWord getSurvivorSpacesCapacity();
 
     /** The capacity of the young generation, comprising the eden and survivor spaces. */
@@ -200,6 +202,7 @@ public interface CollectionPolicy {
      * 1 (straight from eden) and the {@linkplain HeapParameters#getMaxSurvivorSpaces() number of
      * survivor spaces + 1}.
      */
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     int getTenuringAge();
 
     /** Called at the beginning of a collection, in the safepoint operation. */
diff --git a/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/CompleteGarbageCollectorMXBean.java b/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/CompleteGarbageCollectorMXBean.java
index 3515aab4fb2..e991441a0f1 100644
--- a/graal/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/CompleteGarbageCollectorMXBean.java
+++ b/graal/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/CompleteGarbageCollectorMXBean.java
@@ -48,12 +48,12 @@ public final class CompleteGarbageCollectorMXBean implements com.sun.management.
 
     @Override
     public long getCollectionCount() {
-        return HeapImpl.getHeapImpl().getGCImpl().getAccounting().getCompleteCollectionCount();
+        return HeapImpl.getGCImpl().getAccounting().getCompleteCollectionCount();
     }
 
     @Override
     public long getCollectionTime() {
-        long nanos = HeapImpl.getHeapImpl().getGCImpl().getAccounting().getCompleteCollectionTotalNanos();
+        long nanos = HeapImpl.getGCImpl().getAccounting().getCompleteCollectionTotalNanos();
         return TimeUtils.roundNanosToMillis(nanos);
     }
 
diff --git a/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/GCAccounting.java b/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/GCAccounting.java
index 128df06b608..c006ab6faa5 100644
--- a/graal/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/GCAccounting.java
+++ b/graal/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/GCAccounting.java
@@ -30,6 +30,7 @@ import org.graalvm.word.UnsignedWord;
 import org.graalvm.word.WordFactory;
 
 import com.oracle.svm.core.AlwaysInline;
+import com.oracle.svm.core.Uninterruptible;
 import com.oracle.svm.core.log.Log;
 
 /**
@@ -154,6 +155,7 @@ public final class GCAccounting {
 
     /** Called after an object has been promoted from the young generation to the old generation. */
     @AlwaysInline("GC performance")
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     void onSurvivorOverflowed() {
         lastIncrementalCollectionOverflowedSurvivors = true;
     }
diff --git a/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/GCImpl.java b/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/GCImpl.java
index fc8419d5a49..5b67446114f 100644
--- a/graal/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/GCImpl.java
+++ b/graal/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/GCImpl.java
@@ -44,7 +44,6 @@ import org.graalvm.word.UnsignedWord;
 import org.graalvm.word.WordFactory;
 
 import com.oracle.svm.core.AlwaysInline;
-import com.oracle.svm.core.MemoryWalker;
 import com.oracle.svm.core.NeverInline;
 import com.oracle.svm.core.RuntimeAssertionsSupport;
 import com.oracle.svm.core.SubstrateGCOptions;
@@ -64,6 +63,7 @@ import com.oracle.svm.core.genscavenge.AlignedHeapChunk.AlignedHeader;
 import com.oracle.svm.core.genscavenge.BasicCollectionPolicies.NeverCollect;
 import com.oracle.svm.core.genscavenge.HeapChunk.Header;
 import com.oracle.svm.core.genscavenge.UnalignedHeapChunk.UnalignedHeader;
+import com.oracle.svm.core.genscavenge.parallel.ParallelGC;
 import com.oracle.svm.core.genscavenge.remset.RememberedSet;
 import com.oracle.svm.core.graal.RuntimeCompilation;
 import com.oracle.svm.core.heap.CodeReferenceMapDecoder;
@@ -100,7 +100,6 @@ import com.oracle.svm.core.util.VMError;
 public final class GCImpl implements GC {
     private final GreyToBlackObjRefVisitor greyToBlackObjRefVisitor = new GreyToBlackObjRefVisitor();
     private final GreyToBlackObjectVisitor greyToBlackObjectVisitor = new GreyToBlackObjectVisitor(greyToBlackObjRefVisitor);
-    private final BlackenImageHeapRootsVisitor blackenImageHeapRootsVisitor = new BlackenImageHeapRootsVisitor();
     private final RuntimeCodeCacheWalker runtimeCodeCacheWalker = new RuntimeCodeCacheWalker(greyToBlackObjRefVisitor);
     private final RuntimeCodeCacheCleaner runtimeCodeCacheCleaner = new RuntimeCodeCacheCleaner();
 
@@ -128,6 +127,8 @@ public final class GCImpl implements GC {
     public String getName() {
         if (SubstrateOptions.UseEpsilonGC.getValue()) {
             return "Epsilon GC";
+        } else if (SubstrateOptions.UseParallelGC.getValue()) {
+            return "Parallel GC";
         } else {
             return "Serial GC";
         }
@@ -198,6 +199,10 @@ public final class GCImpl implements GC {
         assert VMOperation.isGCInProgress() : "Collection should be a VMOperation.";
         assert getCollectionEpoch().equal(data.getRequestingEpoch());
 
+        if (ParallelGC.isEnabled()) {
+            ParallelGC.singleton().initialize();
+        }
+
         timers.mutator.closeAt(data.getRequestingNanoTime());
         startCollectionOrExit();
 
@@ -515,7 +520,7 @@ public final class GCImpl implements GC {
 
     @Fold
     public static GCImpl getGCImpl() {
-        GCImpl gcImpl = HeapImpl.getHeapImpl().getGCImpl();
+        GCImpl gcImpl = HeapImpl.getGCImpl();
         assert gcImpl != null;
         return gcImpl;
     }
@@ -525,6 +530,7 @@ public final class GCImpl implements GC {
         collect(cause, true);
     }
 
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     public boolean isCompleteCollection() {
         return completeCollection;
     }
@@ -538,11 +544,7 @@ public final class GCImpl implements GC {
             try {
                 startTicks = JfrGCEvents.startGCPhasePause();
                 try {
-                    if (incremental) {
-                        cheneyScanFromDirtyRoots();
-                    } else {
-                        cheneyScanFromRoots();
-                    }
+                    cheneyScan(incremental);
                 } finally {
                     JfrGCEvents.emitGCPhasePauseEvent(getCollectionEpoch(), incremental ? "Incremental Scan" : "Scan", startTicks);
                 }
@@ -597,6 +599,14 @@ public final class GCImpl implements GC {
                      */
                     boolean keepAllAlignedChunks = incremental;
                     chunkReleaser.release(keepAllAlignedChunks);
+
+                    if (!chunkReleaser.isEmpty()) {
+                        if (ParallelGC.isEnabled()) {
+                            ParallelGC.singleton().scheduleCleanup();
+                        } else {
+                            freeChunks();
+                        }
+                    }
                 } finally {
                     JfrGCEvents.emitGCPhasePauseEvent(getCollectionEpoch(), "Release Spaces", startTicks);
                 }
@@ -615,11 +625,17 @@ public final class GCImpl implements GC {
         }
     }
 
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
+    public void freeChunks() {
+        chunkReleaser.freeChunks();
+    }
+
     /**
      * Visit all the memory that is reserved for runtime compiled code. References from the runtime
      * compiled code to the Java heap must be consider as either strong or weak references,
      * depending on whether the code is currently on the execution stack.
      */
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     private void walkRuntimeCodeCache() {
         Timer walkRuntimeCodeCacheTimer = timers.walkRuntimeCodeCache.open();
         try {
@@ -638,6 +654,16 @@ public final class GCImpl implements GC {
         }
     }
 
+    @Uninterruptible(reason = "We don't want any safepoint checks in the core part of the GC.")
+    private void cheneyScan(boolean incremental) {
+        if (incremental) {
+            cheneyScanFromDirtyRoots();
+        } else {
+            cheneyScanFromRoots();
+        }
+    }
+
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     private void cheneyScanFromRoots() {
         Timer cheneyScanFromRootsTimer = timers.cheneyScanFromRoots.open();
         try {
@@ -707,6 +733,7 @@ public final class GCImpl implements GC {
         }
     }
 
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     private void cheneyScanFromDirtyRoots() {
         Timer cheneyScanFromDirtyRootsTimer = timers.cheneyScanFromDirtyRoots.open();
         try {
@@ -798,6 +825,7 @@ public final class GCImpl implements GC {
         }
     }
 
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     private void promoteChunksWithPinnedObjects() {
         Timer promotePinnedObjectsTimer = timers.promotePinnedObjects.open();
         try {
@@ -821,6 +849,7 @@ public final class GCImpl implements GC {
         }
     }
 
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     private static PinnedObjectImpl removeClosedPinnedObjects(PinnedObjectImpl list) {
         PinnedObjectImpl firstOpen = null;
         PinnedObjectImpl lastOpen = null;
@@ -849,7 +878,7 @@ public final class GCImpl implements GC {
     @NeverInline("Starting a stack walk in the caller frame. " +
                     "Note that we could start the stack frame also further down the stack, because GC stack frames must not access any objects that are processed by the GC. " +
                     "But we don't store stack frame information for the first frame we would need to process.")
-    @Uninterruptible(reason = "Required by called JavaStackWalker methods. We are at a safepoint during GC, so it does not change anything for this method.", calleeMustBe = false)
+    @Uninterruptible(reason = "Required by called JavaStackWalker methods. We are at a safepoint during GC, so it does not change anything for this method.")
     private void blackenStackRoots() {
         Timer blackenStackRootsTimer = timers.blackenStackRoots.open();
         try {
@@ -891,7 +920,7 @@ public final class GCImpl implements GC {
      * {@link SimpleCodeInfoQueryResult} twice per frame, and also ensures that there are no virtual
      * calls to a stack frame visitor.
      */
-    @Uninterruptible(reason = "Required by called JavaStackWalker methods. We are at a safepoint during GC, so it does not change anything for this method.", calleeMustBe = false)
+    @Uninterruptible(reason = "Required by called JavaStackWalker methods. We are at a safepoint during GC, so it does not change anything for this method.")
     private void walkStack(JavaStackWalk walk) {
         assert VMOperation.isGCInProgress() : "This methods accesses a CodeInfo without a tether";
 
@@ -943,6 +972,7 @@ public final class GCImpl implements GC {
         }
     }
 
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     private void walkThreadLocals() {
         if (SubstrateOptions.MultiThreaded.getValue()) {
             Timer walkThreadLocalsTimer = timers.walkThreadLocals.open();
@@ -956,6 +986,7 @@ public final class GCImpl implements GC {
         }
     }
 
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     private void blackenDirtyImageHeapRoots() {
         if (!HeapImpl.usesImageHeapCardMarking()) {
             blackenImageHeapRoots();
@@ -978,6 +1009,7 @@ public final class GCImpl implements GC {
         }
     }
 
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     private void blackenDirtyImageHeapChunkRoots(AlignedHeader firstAligned, UnalignedHeader firstUnaligned) {
         /*
          * We clean and remark cards of the image heap only during complete collections when we also
@@ -999,6 +1031,7 @@ public final class GCImpl implements GC {
         }
     }
 
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     private void blackenImageHeapRoots() {
         if (HeapImpl.usesImageHeapCardMarking()) {
             // Avoid scanning the entire image heap even for complete collections: its remembered
@@ -1009,22 +1042,25 @@ public final class GCImpl implements GC {
 
         Timer blackenImageHeapRootsTimer = timers.blackenImageHeapRoots.open();
         try {
-            HeapImpl.getHeapImpl().walkNativeImageHeapRegions(blackenImageHeapRootsVisitor);
+            blackenImageHeapRoots(HeapImpl.getImageHeapInfo());
+            if (AuxiliaryImageHeap.isPresent()) {
+                ImageHeapInfo auxImageHeapInfo = AuxiliaryImageHeap.singleton().getImageHeapInfo();
+                if (auxImageHeapInfo != null) {
+                    blackenImageHeapRoots(auxImageHeapInfo);
+                }
+            }
         } finally {
             blackenImageHeapRootsTimer.close();
         }
     }
 
-    private class BlackenImageHeapRootsVisitor implements MemoryWalker.ImageHeapRegionVisitor {
-        @Override
-        public <T> boolean visitNativeImageHeapRegion(T region, MemoryWalker.NativeImageHeapRegionAccess<T> access) {
-            if (access.containsReferences(region) && access.isWritable(region)) {
-                access.visitObjects(region, greyToBlackObjectVisitor);
-            }
-            return true;
-        }
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
+    private void blackenImageHeapRoots(ImageHeapInfo imageHeapInfo) {
+        ImageHeapWalker.walkPartitionInline(imageHeapInfo.firstWritableReferenceObject, imageHeapInfo.lastWritableReferenceObject, greyToBlackObjectVisitor, true);
+        ImageHeapWalker.walkPartitionInline(imageHeapInfo.firstWritableHugeObject, imageHeapInfo.lastWritableHugeObject, greyToBlackObjectVisitor, false);
     }
 
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     private void blackenDirtyCardRoots() {
         Timer blackenDirtyCardRootsTimer = timers.blackenDirtyCardRoots.open();
         try {
@@ -1039,6 +1075,7 @@ public final class GCImpl implements GC {
         }
     }
 
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     private static void prepareForPromotion(boolean isIncremental) {
         HeapImpl heap = HeapImpl.getHeapImpl();
         heap.getOldGeneration().prepareForPromotion();
@@ -1047,10 +1084,13 @@ public final class GCImpl implements GC {
         }
     }
 
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     private void scanGreyObjects(boolean isIncremental) {
         Timer scanGreyObjectsTimer = timers.scanGreyObjects.open();
         try {
-            if (isIncremental) {
+            if (ParallelGC.isEnabled()) {
+                ParallelGC.singleton().scheduleScan();
+            } else if (isIncremental) {
                 scanGreyObjectsLoop();
             } else {
                 HeapImpl.getHeapImpl().getOldGeneration().scanGreyObjects();
@@ -1060,6 +1100,7 @@ public final class GCImpl implements GC {
         }
     }
 
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     private static void scanGreyObjectsLoop() {
         HeapImpl heap = HeapImpl.getHeapImpl();
         YoungGeneration youngGen = heap.getYoungGeneration();
@@ -1072,20 +1113,24 @@ public final class GCImpl implements GC {
     }
 
     @AlwaysInline("GC performance")
-    @SuppressWarnings("static-method")
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     Object promoteObject(Object original, UnsignedWord header) {
         HeapImpl heap = HeapImpl.getHeapImpl();
         boolean isAligned = ObjectHeaderImpl.isAlignedHeader(header);
         Header<?> originalChunk = getChunk(original, isAligned);
+
+        /* If the parallel GC is used, then the space may be outdated or null. */
         Space originalSpace = HeapChunk.getSpace(originalChunk);
-        if (!originalSpace.isFromSpace()) {
+        assert originalSpace != null || ParallelGC.isEnabled() && ParallelGC.singleton().isInParallelPhase();
+        if (originalSpace == null || !originalSpace.isFromSpace()) {
+            /* Object was already promoted or is currently being promoted. */
             return original;
         }
 
         Object result = null;
         if (!completeCollection && originalSpace.getNextAgeForPromotion() < policy.getTenuringAge()) {
             if (isAligned) {
-                result = heap.getYoungGeneration().promoteAlignedObject(original, (AlignedHeader) originalChunk, originalSpace);
+                result = heap.getYoungGeneration().promoteAlignedObject(original, originalSpace);
             } else {
                 result = heap.getYoungGeneration().promoteUnalignedObject(original, (UnalignedHeader) originalChunk, originalSpace);
             }
@@ -1093,11 +1138,13 @@ public final class GCImpl implements GC {
                 accounting.onSurvivorOverflowed();
             }
         }
-        if (result == null) { // complete collection, tenuring age reached, or survivor space full
+
+        /* Complete collection, tenuring age reached, or survivor space full. */
+        if (result == null) {
             if (isAligned) {
-                result = heap.getOldGeneration().promoteAlignedObject(original, (AlignedHeader) originalChunk, originalSpace);
+                result = heap.getOldGeneration().promoteAlignedObject(original, originalSpace);
             } else {
-                result = heap.getOldGeneration().promoteUnalignedObject(original, (UnalignedHeader) originalChunk, originalSpace);
+                result = heap.getOldGeneration().promoteUnalignedObject(original, (UnalignedHeader) originalChunk);
             }
             assert result != null : "promotion failure in old generation must have been handled";
         }
@@ -1105,6 +1152,7 @@ public final class GCImpl implements GC {
         return result;
     }
 
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     private static Header<?> getChunk(Object obj, boolean isAligned) {
         if (isAligned) {
             return AlignedHeapChunk.getEnclosingChunk(obj);
@@ -1113,6 +1161,7 @@ public final class GCImpl implements GC {
         return UnalignedHeapChunk.getEnclosingChunk(obj);
     }
 
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     private void promotePinnedObject(PinnedObjectImpl pinned) {
         HeapImpl heap = HeapImpl.getHeapImpl();
         Object referent = pinned.getObject();
@@ -1129,7 +1178,7 @@ public final class GCImpl implements GC {
                     }
                 }
                 if (!promoted) {
-                    heap.getOldGeneration().promoteChunk(originalChunk, isAligned, originalSpace);
+                    heap.getOldGeneration().promoteChunk(originalChunk, isAligned);
                 }
             }
         }
@@ -1217,7 +1266,8 @@ public final class GCImpl implements GC {
         return getPolicy() instanceof NeverCollect;
     }
 
-    GreyToBlackObjectVisitor getGreyToBlackObjectVisitor() {
+    @Fold
+    public GreyToBlackObjectVisitor getGreyToBlackObjectVisitor() {
         return greyToBlackObjectVisitor;
     }
 
@@ -1266,7 +1316,7 @@ public final class GCImpl implements GC {
              */
             ImplicitExceptions.activateImplicitExceptionsAreFatal();
             try {
-                HeapImpl.getHeapImpl().getGCImpl().collectOperation((CollectionVMOperationData) data);
+                HeapImpl.getGCImpl().collectOperation((CollectionVMOperationData) data);
             } catch (Throwable t) {
                 throw VMError.shouldNotReachHere(t);
             } finally {
@@ -1277,7 +1327,7 @@ public final class GCImpl implements GC {
         @Override
         protected boolean hasWork(NativeVMOperationData data) {
             CollectionVMOperationData d = (CollectionVMOperationData) data;
-            return HeapImpl.getHeapImpl().getGCImpl().getCollectionEpoch().equal(d.getRequestingEpoch());
+            return HeapImpl.getGCImpl().getCollectionEpoch().equal(d.getRequestingEpoch());
         }
     }
 
@@ -1326,6 +1376,7 @@ public final class GCImpl implements GC {
             return firstAligned.isNull() && firstUnaligned.isNull();
         }
 
+        @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
         public void add(AlignedHeader chunks) {
             if (chunks.isNonNull()) {
                 assert HeapChunk.getPrevious(chunks).isNull() : "prev must be null";
@@ -1338,6 +1389,7 @@ public final class GCImpl implements GC {
             }
         }
 
+        @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
         public void add(UnalignedHeader chunks) {
             if (chunks.isNonNull()) {
                 assert HeapChunk.getPrevious(chunks).isNull() : "prev must be null";
@@ -1352,15 +1404,19 @@ public final class GCImpl implements GC {
 
         void release(boolean keepAllAlignedChunks) {
             if (firstAligned.isNonNull()) {
-                HeapImpl.getChunkProvider().consumeAlignedChunks(firstAligned, keepAllAlignedChunks);
-                firstAligned = WordFactory.nullPointer();
-            }
-            if (firstUnaligned.isNonNull()) {
-                HeapChunkProvider.consumeUnalignedChunks(firstUnaligned);
-                firstUnaligned = WordFactory.nullPointer();
+                firstAligned = HeapImpl.getChunkProvider().consumeAlignedChunks(firstAligned, keepAllAlignedChunks);
             }
         }
 
+        @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
+        void freeChunks() {
+            HeapChunkProvider.freeAlignedChunkList(firstAligned);
+            firstAligned = WordFactory.nullPointer();
+            HeapChunkProvider.consumeUnalignedChunks(firstUnaligned);
+            firstUnaligned = WordFactory.nullPointer();
+        }
+
+        @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
         private static <T extends Header<T>> T getLast(T chunks) {
             T prev = chunks;
             T next = HeapChunk.getNext(prev);
diff --git a/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/GenScavengeMemoryPoolMXBeans.java b/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/GenScavengeMemoryPoolMXBeans.java
index 4e0daf2c7dc..ac3dff830bb 100644
--- a/graal/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/GenScavengeMemoryPoolMXBeans.java
+++ b/graal/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/GenScavengeMemoryPoolMXBeans.java
@@ -46,7 +46,7 @@ public class GenScavengeMemoryPoolMXBeans {
 
     @Platforms(Platform.HOSTED_ONLY.class)
     public static MemoryPoolMXBean[] createMemoryPoolMXBeans() {
-        if (SubstrateOptions.UseSerialGC.getValue()) {
+        if (SubstrateOptions.useSerialOrParallelGC()) {
             mxBeans = new AbstractMemoryPoolMXBean[]{
                             new EdenMemoryPoolMXBean(YOUNG_GEN_SCAVENGER, COMPLETE_SCAVENGER),
                             new SurvivorMemoryPoolMXBean(YOUNG_GEN_SCAVENGER, COMPLETE_SCAVENGER),
diff --git a/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/Generation.java b/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/Generation.java
index 35b694891c1..d5559bd77e5 100644
--- a/graal/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/Generation.java
+++ b/graal/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/Generation.java
@@ -53,42 +53,4 @@ abstract class Generation {
 
     /** Report some statistics about the Generation to a Log. */
     public abstract Log report(Log log, boolean traceHeapChunks);
-
-    /**
-     * Promote an Object to this Generation, typically by copying and leaving a forwarding pointer
-     * to the new Object in place of the original Object. If the object cannot be promoted due to
-     * insufficient capacity, returns {@code null}.
-     *
-     * This turns an Object from white to grey: the object is in this Generation, but has not yet
-     * had its interior pointers visited.
-     *
-     * @return a reference to the promoted object, which is different to the original reference if
-     *         promotion was done by copying, or {@code null} if there was insufficient capacity in
-     *         this generation.
-     */
-    protected abstract Object promoteAlignedObject(Object original, AlignedHeapChunk.AlignedHeader originalChunk, Space originalSpace);
-
-    /**
-     * Promote an Object to this Generation, typically by HeapChunk motion. If the object cannot be
-     * promoted due to insufficient capacity, returns {@code null}.
-     *
-     * This turns an Object from white to grey: the object is in this Generation, but has not yet
-     * had its interior pointers visited.
-     *
-     * @return a reference to the promoted object, which is the same as the original if the object
-     *         was promoted through HeapChunk motion, or {@code null} if there was insufficient
-     *         capacity in this generation.
-     */
-    protected abstract Object promoteUnalignedObject(Object original, UnalignedHeapChunk.UnalignedHeader originalChunk, Space originalSpace);
-
-    /**
-     * Promote a HeapChunk from its original space to the appropriate space in this generation if
-     * there is sufficient capacity.
-     *
-     * This turns all the Objects in the chunk from white to grey: the objects are in the target
-     * Space, but have not yet had their interior pointers visited.
-     *
-     * @return true on success, false if the there was insufficient capacity.
-     */
-    protected abstract boolean promoteChunk(HeapChunk.Header<?> originalChunk, boolean isAligned, Space originalSpace);
 }
diff --git a/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/GreyObjectsWalker.java b/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/GreyObjectsWalker.java
index f05a03126e0..efde96ef376 100644
--- a/graal/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/GreyObjectsWalker.java
+++ b/graal/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/GreyObjectsWalker.java
@@ -31,7 +31,7 @@ import org.graalvm.word.WordFactory;
 
 import com.oracle.svm.core.AlwaysInline;
 import com.oracle.svm.core.NeverInline;
-import com.oracle.svm.core.log.Log;
+import com.oracle.svm.core.Uninterruptible;
 import com.oracle.svm.core.util.VMError;
 
 /**
@@ -57,26 +57,25 @@ final class GreyObjectsWalker {
      * Take a snapshot of a Space, such that all Objects in the Space are now black, and any new
      * Objects in the Space will be grey, and can have an ObjectVisitor applied to them.
      */
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     void setScanStart(Space s) {
-        Log trace = Log.noopLog().string("[Space.GreyObjectsWalker.setScanStart:").string("  s: ").string(s.getName());
         space = s;
         AlignedHeapChunk.AlignedHeader aChunk = s.getLastAlignedHeapChunk();
         alignedHeapChunk = aChunk;
-        trace.string("  alignedHeapChunk: ").zhex(alignedHeapChunk).string("  isNull: ").bool(aChunk.isNull());
         alignedTop = (aChunk.isNonNull() ? HeapChunk.getTopPointer(aChunk) : WordFactory.nullPointer());
-        trace.string("  alignedTop: ").zhex(alignedTop);
         unalignedHeapChunk = s.getLastUnalignedHeapChunk();
-        trace.string("  unalignedChunkPointer: ").zhex(unalignedHeapChunk).string("]").newline();
     }
 
     /** Compare the snapshot to the current state of the Space to see if there are grey Objects. */
     @AlwaysInline("GC performance")
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     boolean haveGreyObjects() {
         return alignedHeapChunk.notEqual(space.getLastAlignedHeapChunk()) || alignedHeapChunk.isNonNull() && alignedTop.notEqual(HeapChunk.getTopPointer(alignedHeapChunk)) ||
                         unalignedHeapChunk.notEqual(space.getLastUnalignedHeapChunk());
     }
 
     @NeverInline("Split the GC into reasonable compilation units")
+    @Uninterruptible(reason = "Called from uninterruptible code.")
     void walkGreyObjects() {
         while (haveGreyObjects()) {
             walkAlignedGreyObjects();
@@ -85,6 +84,7 @@ final class GreyObjectsWalker {
     }
 
     @AlwaysInline("GC performance")
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     private void walkAlignedGreyObjects() {
         AlignedHeapChunk.AlignedHeader aChunk;
         if (alignedHeapChunk.isNull() && alignedTop.isNull()) {
@@ -113,6 +113,7 @@ final class GreyObjectsWalker {
     }
 
     @AlwaysInline("GC performance")
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     private void walkUnalignedGreyObjects() {
         /* Visit the Objects in the UnalignedChunk after the snapshot UnalignedChunk. */
         UnalignedHeapChunk.UnalignedHeader uChunk;
diff --git a/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/GreyToBlackObjRefVisitor.java b/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/GreyToBlackObjRefVisitor.java
index 03105a9b19f..353443ea82d 100644
--- a/graal/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/GreyToBlackObjRefVisitor.java
+++ b/graal/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/GreyToBlackObjRefVisitor.java
@@ -30,10 +30,13 @@ import org.graalvm.nativeimage.Platforms;
 import org.graalvm.word.Pointer;
 
 import com.oracle.svm.core.AlwaysInline;
+import com.oracle.svm.core.Uninterruptible;
+import com.oracle.svm.core.genscavenge.parallel.ParallelGC;
 import com.oracle.svm.core.genscavenge.remset.RememberedSet;
 import com.oracle.svm.core.heap.ObjectReferenceVisitor;
 import com.oracle.svm.core.heap.ReferenceAccess;
 import com.oracle.svm.core.hub.LayoutEncoding;
+import com.oracle.svm.core.jdk.UninterruptibleUtils.AtomicLong;
 import com.oracle.svm.core.log.Log;
 
 /**
@@ -58,12 +61,14 @@ final class GreyToBlackObjRefVisitor implements ObjectReferenceVisitor {
     }
 
     @Override
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     public boolean visitObjectReference(Pointer objRef, boolean compressed, Object holderObject) {
         return visitObjectReferenceInline(objRef, 0, compressed, holderObject);
     }
 
     @Override
     @AlwaysInline("GC performance")
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     public boolean visitObjectReferenceInline(Pointer objRef, int innerOffset, boolean compressed, Object holderObject) {
         assert innerOffset >= 0;
         assert !objRef.isNull();
@@ -93,6 +98,8 @@ final class GreyToBlackObjRefVisitor implements ObjectReferenceVisitor {
                 counters.noteForwardedReferent();
                 // Update the reference to point to the forwarded Object.
                 Object obj = ohi.getForwardedObject(p, header);
+                assert ParallelGC.isEnabled() && ParallelGC.singleton().isInParallelPhase() ||
+                                innerOffset < LayoutEncoding.getSizeFromObjectInGC(obj).rawValue();
                 Object offsetObj = (innerOffset == 0) ? obj : Word.objectToUntrackedPointer(obj).add(innerOffset).toObject();
                 ReferenceAccess.singleton().writeObjectAt(objRef, offsetObj, compressed);
                 RememberedSet.get().dirtyCardIfNecessary(holderObject, obj);
@@ -101,11 +108,12 @@ final class GreyToBlackObjRefVisitor implements ObjectReferenceVisitor {
 
             // Promote the Object if necessary, making it at least grey, and ...
             Object obj = p.toObject();
-            assert innerOffset < LayoutEncoding.getSizeFromObjectInGC(obj).rawValue();
             Object copy = GCImpl.getGCImpl().promoteObject(obj, header);
             if (copy != obj) {
                 // ... update the reference to point to the copy, making the reference black.
                 counters.noteCopiedReferent();
+                assert ParallelGC.isEnabled() && ParallelGC.singleton().isInParallelPhase() ||
+                                innerOffset < LayoutEncoding.getSizeFromObjectInGC(copy).rawValue();
                 Object offsetCopy = (innerOffset == 0) ? copy : Word.objectToUntrackedPointer(copy).add(innerOffset).toObject();
                 ReferenceAccess.singleton().writeObjectAt(objRef, offsetCopy, compressed);
             } else {
@@ -130,31 +138,35 @@ final class GreyToBlackObjRefVisitor implements ObjectReferenceVisitor {
         @Override
         void close();
 
+        @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
         void noteObjRef();
 
+        @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
         void noteNullReferent();
 
+        @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
         void noteForwardedReferent();
 
+        @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
         void noteNonHeapReferent();
 
+        @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
         void noteCopiedReferent();
 
+        @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
         void noteUnmodifiedReference();
 
-        void toLog();
-
         void reset();
     }
 
     public static class RealCounters implements Counters {
-        private long objRef;
-        private long nullObjRef;
-        private long nullReferent;
-        private long forwardedReferent;
-        private long nonHeapReferent;
-        private long copiedReferent;
-        private long unmodifiedReference;
+        private final AtomicLong objRef = new AtomicLong(0);
+        private final AtomicLong nullObjRef = new AtomicLong(0);
+        private final AtomicLong nullReferent = new AtomicLong(0);
+        private final AtomicLong forwardedReferent = new AtomicLong(0);
+        private final AtomicLong nonHeapReferent = new AtomicLong(0);
+        private final AtomicLong copiedReferent = new AtomicLong(0);
+        private final AtomicLong unmodifiedReference = new AtomicLong(0);
 
         RealCounters() {
             reset();
@@ -162,13 +174,13 @@ final class GreyToBlackObjRefVisitor implements ObjectReferenceVisitor {
 
         @Override
         public void reset() {
-            objRef = 0L;
-            nullObjRef = 0L;
-            nullReferent = 0L;
-            forwardedReferent = 0L;
-            nonHeapReferent = 0L;
-            copiedReferent = 0L;
-            unmodifiedReference = 0L;
+            objRef.set(0L);
+            nullObjRef.set(0L);
+            nullReferent.set(0L);
+            forwardedReferent.set(0L);
+            nonHeapReferent.set(0L);
+            copiedReferent.set(0L);
+            unmodifiedReference.set(0L);
         }
 
         @Override
@@ -184,46 +196,51 @@ final class GreyToBlackObjRefVisitor implements ObjectReferenceVisitor {
         }
 
         @Override
+        @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
         public void noteObjRef() {
-            objRef += 1L;
+            objRef.incrementAndGet();
         }
 
         @Override
+        @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
         public void noteNullReferent() {
-            nullReferent += 1L;
+            nullReferent.incrementAndGet();
         }
 
         @Override
+        @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
         public void noteForwardedReferent() {
-            forwardedReferent += 1L;
+            forwardedReferent.incrementAndGet();
         }
 
         @Override
+        @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
         public void noteNonHeapReferent() {
-            nonHeapReferent += 1L;
+            nonHeapReferent.incrementAndGet();
         }
 
         @Override
+        @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
         public void noteCopiedReferent() {
-            copiedReferent += 1L;
+            copiedReferent.incrementAndGet();
         }
 
         @Override
+        @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
         public void noteUnmodifiedReference() {
-            unmodifiedReference += 1L;
+            unmodifiedReference.incrementAndGet();
         }
 
-        @Override
-        public void toLog() {
+        private void toLog() {
             Log log = Log.log();
             log.string("[GreyToBlackObjRefVisitor.counters:");
-            log.string("  objRef: ").signed(objRef);
-            log.string("  nullObjRef: ").signed(nullObjRef);
-            log.string("  nullReferent: ").signed(nullReferent);
-            log.string("  forwardedReferent: ").signed(forwardedReferent);
-            log.string("  nonHeapReferent: ").signed(nonHeapReferent);
-            log.string("  copiedReferent: ").signed(copiedReferent);
-            log.string("  unmodifiedReference: ").signed(unmodifiedReference);
+            log.string("  objRef: ").signed(objRef.get());
+            log.string("  nullObjRef: ").signed(nullObjRef.get());
+            log.string("  nullReferent: ").signed(nullReferent.get());
+            log.string("  forwardedReferent: ").signed(forwardedReferent.get());
+            log.string("  nonHeapReferent: ").signed(nonHeapReferent.get());
+            log.string("  copiedReferent: ").signed(copiedReferent.get());
+            log.string("  unmodifiedReference: ").signed(unmodifiedReference.get());
             log.string("]").newline();
         }
     }
@@ -243,33 +260,35 @@ final class GreyToBlackObjRefVisitor implements ObjectReferenceVisitor {
         }
 
         @Override
+        @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
         public void noteObjRef() {
         }
 
         @Override
+        @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
         public void noteNullReferent() {
         }
 
         @Override
+        @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
         public void noteForwardedReferent() {
         }
 
         @Override
+        @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
         public void noteNonHeapReferent() {
         }
 
         @Override
+        @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
         public void noteCopiedReferent() {
         }
 
         @Override
+        @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
         public void noteUnmodifiedReference() {
         }
 
-        @Override
-        public void toLog() {
-        }
-
         @Override
         public void reset() {
         }
diff --git a/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/GreyToBlackObjectVisitor.java b/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/GreyToBlackObjectVisitor.java
index 9a8b48845d4..bc432b86626 100644
--- a/graal/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/GreyToBlackObjectVisitor.java
+++ b/graal/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/GreyToBlackObjectVisitor.java
@@ -29,6 +29,7 @@ import org.graalvm.nativeimage.Platforms;
 
 import com.oracle.svm.core.AlwaysInline;
 import com.oracle.svm.core.NeverInline;
+import com.oracle.svm.core.Uninterruptible;
 import com.oracle.svm.core.heap.ObjectVisitor;
 import com.oracle.svm.core.hub.InteriorObjRefWalker;
 import com.oracle.svm.core.util.VMError;
@@ -55,6 +56,7 @@ public final class GreyToBlackObjectVisitor implements ObjectVisitor {
 
     @Override
     @AlwaysInline("GC performance")
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     public boolean visitObjectInline(Object o) {
         ReferenceObjectProcessing.discoverIfReference(o, objRefVisitor);
         InteriorObjRefWalker.walkObjectInline(o, objRefVisitor);
diff --git a/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/HeapChunk.java b/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/HeapChunk.java
index 69104f59be4..e23833330e5 100644
--- a/graal/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/HeapChunk.java
+++ b/graal/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/HeapChunk.java
@@ -177,12 +177,13 @@ public final class HeapChunk {
         void setIdentityHashSalt(UnsignedWord value, LocationIdentity identity);
     }
 
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     public static void initialize(Header<?> chunk, Pointer objectsStart, UnsignedWord chunkSize) {
         HeapChunk.setEndOffset(chunk, chunkSize);
         HeapChunk.setTopPointer(chunk, objectsStart);
-        HeapChunk.setSpace(chunk, null);
-        HeapChunk.setNext(chunk, WordFactory.nullPointer());
-        HeapChunk.setPrevious(chunk, WordFactory.nullPointer());
+        chunk.setSpace(null);
+        chunk.setOffsetToNextChunk(WordFactory.zero());
+        chunk.setOffsetToPreviousChunk(WordFactory.zero());
 
         /*
          * The epoch is obviously not random, but cheap to use, and we cannot use a random number
@@ -232,6 +233,10 @@ public final class HeapChunk {
         that.setEndOffset(newEnd);
     }
 
+    /**
+     * If the parallel GC is used, then this method is racy. So, it may return null or an outdated
+     * value if it is called for an unaligned heap chunk that is in the middle of being promoted.
+     */
     @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     public static Space getSpace(Header<?> that) {
         return that.getSpace();
@@ -239,6 +244,7 @@ public final class HeapChunk {
 
     @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     public static void setSpace(Header<?> that, Space newSpace) {
+        assert newSpace == null || that.getSpace() == null : "heap chunk must be removed from its current space before it can be registered with a new space";
         that.setSpace(newSpace);
     }
 
@@ -263,8 +269,8 @@ public final class HeapChunk {
     }
 
     @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
-    public static UnsignedWord getIdentityHashSalt(Header<?> that) {
-        return that.getIdentityHashSalt(IdentityHashCodeSupport.IDENTITY_HASHCODE_SALT_LOCATION);
+    public static long getIdentityHashSalt(Header<?> that) {
+        return that.getIdentityHashSalt(IdentityHashCodeSupport.IDENTITY_HASHCODE_SALT_LOCATION).rawValue();
     }
 
     @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
@@ -306,11 +312,12 @@ public final class HeapChunk {
     }
 
     @AlwaysInline("GC performance")
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     public static boolean walkObjectsFromInline(Header<?> that, Pointer startOffset, ObjectVisitor visitor) {
         Pointer offset = startOffset;
         while (offset.belowThan(getTopPointer(that))) { // crucial: top can move, so always re-read
             Object obj = offset.toObject();
-            if (!visitor.visitObjectInline(obj)) {
+            if (!callVisitor(visitor, obj)) {
                 return false;
             }
             offset = offset.add(LayoutEncoding.getSizeFromObjectInlineInGC(obj));
@@ -318,6 +325,11 @@ public final class HeapChunk {
         return true;
     }
 
+    @Uninterruptible(reason = "Bridge between uninterruptible and potentially interruptible code.", mayBeInlined = true, calleeMustBe = false)
+    private static boolean callVisitor(ObjectVisitor visitor, Object obj) {
+        return visitor.visitObjectInline(obj);
+    }
+
     @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     public static UnsignedWord availableObjectMemory(Header<?> that) {
         return that.getEndOffset().subtract(that.getTopOffset());
@@ -344,6 +356,7 @@ public final class HeapChunk {
         }
     }
 
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     public static HeapChunk.Header<?> getEnclosingHeapChunk(Pointer ptrToObj, UnsignedWord header) {
         if (ObjectHeaderImpl.isAlignedHeader(header)) {
             return AlignedHeapChunk.getEnclosingChunkFromObjectPointer(ptrToObj);
@@ -366,26 +379,5 @@ public final class HeapChunk {
         public UnsignedWord getSize(T heapChunk) {
             return HeapChunk.getEndOffset(heapChunk);
         }
-
-        @Override
-        public UnsignedWord getAllocationEnd(T heapChunk) {
-            return HeapChunk.getTopPointer(heapChunk);
-        }
-
-        @Override
-        public String getRegion(T heapChunk) {
-            /* This method knows too much about spaces, especially the "free" space. */
-            Space space = getSpace(heapChunk);
-            String result;
-            if (space == null) {
-                result = "free";
-            } else if (space.isYoungSpace()) {
-                result = "young";
-            } else {
-                result = "old";
-            }
-            return result;
-        }
-
     }
 }
diff --git a/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/HeapChunkProvider.java b/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/HeapChunkProvider.java
index 52696391504..3aee680b630 100644
--- a/graal/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/HeapChunkProvider.java
+++ b/graal/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/HeapChunkProvider.java
@@ -24,6 +24,7 @@
  */
 package com.oracle.svm.core.genscavenge;
 
+import com.oracle.svm.core.genscavenge.parallel.ParallelGC;
 import org.graalvm.nativeimage.Platform;
 import org.graalvm.nativeimage.Platforms;
 import org.graalvm.word.Pointer;
@@ -89,23 +90,15 @@ final class HeapChunkProvider {
         return bytesInUnusedAlignedChunks.get();
     }
 
-    @AlwaysInline("Remove all logging when noopLog is returned by this method")
-    private static Log log() {
-        return Log.noopLog();
-    }
-
     private static final OutOfMemoryError ALIGNED_OUT_OF_MEMORY_ERROR = new OutOfMemoryError("Could not allocate an aligned heap chunk");
 
     private static final OutOfMemoryError UNALIGNED_OUT_OF_MEMORY_ERROR = new OutOfMemoryError("Could not allocate an unaligned heap chunk");
 
     /** Acquire a new AlignedHeapChunk, either from the free list or from the operating system. */
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     AlignedHeader produceAlignedChunk() {
         UnsignedWord chunkSize = HeapParameters.getAlignedHeapChunkSize();
-        log().string("[HeapChunkProvider.produceAlignedChunk  chunk size: ").unsigned(chunkSize).newline();
-
         AlignedHeader result = popUnusedAlignedChunk();
-        log().string("  unused chunk: ").zhex(result).newline();
-
         if (result.isNull()) {
             /* Unused list was empty, need to allocate memory. */
             noteFirstAllocationTime();
@@ -113,7 +106,6 @@ final class HeapChunkProvider {
             if (result.isNull()) {
                 throw OutOfMemoryUtil.reportOutOfMemoryError(ALIGNED_OUT_OF_MEMORY_ERROR);
             }
-            log().string("  new chunk: ").zhex(result).newline();
 
             AlignedHeapChunk.initialize(result, chunkSize);
         }
@@ -123,8 +115,6 @@ final class HeapChunkProvider {
         if (HeapParameters.getZapProducedHeapChunks()) {
             zap(result, HeapParameters.getProducedHeapChunkZapWord());
         }
-
-        log().string("  result chunk: ").zhex(result).string("  ]").newline();
         return result;
     }
 
@@ -137,7 +127,7 @@ final class HeapChunkProvider {
      * Releases a list of AlignedHeapChunks, either to the free list or back to the operating
      * system. This method may only be called after the chunks were already removed from the spaces.
      */
-    void consumeAlignedChunks(AlignedHeader firstChunk, boolean keepAll) {
+    AlignedHeader consumeAlignedChunks(AlignedHeader firstChunk, boolean keepAll) {
         assert VMOperation.isGCInProgress();
         assert firstChunk.isNull() || HeapChunk.getPrevious(firstChunk).isNull() : "prev must be null";
 
@@ -169,10 +159,10 @@ final class HeapChunkProvider {
             maxChunksToKeep = maxChunksToKeep.subtract(1);
             cur = next;
         }
-        freeAlignedChunkList(cur);
 
         // Release chunks from the free list to the operating system when spaces shrink
         freeUnusedAlignedChunksAtSafepoint(unusedChunksToFree);
+        return cur;
     }
 
     private static void cleanAlignedChunk(AlignedHeader alignedChunk) {
@@ -200,13 +190,10 @@ final class HeapChunkProvider {
         if (SubstrateOptions.MultiThreaded.getValue()) {
             VMThreads.guaranteeOwnsThreadMutex("Should hold the lock when pushing to the global list.");
         }
-        log().string("  old list top: ").zhex(unusedAlignedChunks.get()).string("  list bytes ").signed(bytesInUnusedAlignedChunks.get()).newline();
 
         HeapChunk.setNext(chunk, unusedAlignedChunks.get());
         unusedAlignedChunks.set(chunk);
         bytesInUnusedAlignedChunks.addAndGet(HeapParameters.getAlignedHeapChunkSize());
-
-        log().string("  new list top: ").zhex(unusedAlignedChunks.get()).string("  list bytes ").signed(bytesInUnusedAlignedChunks.get()).newline();
     }
 
     /**
@@ -218,15 +205,13 @@ final class HeapChunkProvider {
      * garbage collections, I avoid the ABA problem by making the kernel of this method
      * uninterruptible so it can not be interrupted by a safepoint.
      */
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     private AlignedHeader popUnusedAlignedChunk() {
-        log().string("  old list top: ").zhex(unusedAlignedChunks.get()).string("  list bytes ").signed(bytesInUnusedAlignedChunks.get()).newline();
-
         AlignedHeader result = popUnusedAlignedChunkUninterruptibly();
         if (result.isNull()) {
             return WordFactory.nullPointer();
         } else {
             bytesInUnusedAlignedChunks.subtractAndGet(HeapParameters.getAlignedHeapChunkSize());
-            log().string("  new list top: ").zhex(unusedAlignedChunks.get()).string("  list bytes ").signed(bytesInUnusedAlignedChunks.get()).newline();
             return result;
         }
     }
@@ -268,7 +253,6 @@ final class HeapChunkProvider {
     /** Acquire an UnalignedHeapChunk from the operating system. */
     UnalignedHeader produceUnalignedChunk(UnsignedWord objectSize) {
         UnsignedWord chunkSize = UnalignedHeapChunk.getChunkSizeForObject(objectSize);
-        log().string("[HeapChunkProvider.produceUnalignedChunk  objectSize: ").unsigned(objectSize).string("  chunkSize: ").zhex(chunkSize).newline();
 
         noteFirstAllocationTime();
         UnalignedHeader result = (UnalignedHeader) CommittedMemoryProvider.get().allocateUnalignedChunk(chunkSize);
@@ -283,8 +267,6 @@ final class HeapChunkProvider {
         if (!CommittedMemoryProvider.get().areUnalignedChunksZeroed() && HeapParameters.getZapProducedHeapChunks()) {
             zap(result, HeapParameters.getProducedHeapChunkZapWord());
         }
-
-        log().string("  returns ").zhex(result).string("  ]").newline();
         return result;
     }
 
@@ -296,15 +278,16 @@ final class HeapChunkProvider {
      * Releases a list of UnalignedHeapChunks back to the operating system. They are never recycled
      * to a free list.
      */
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     static void consumeUnalignedChunks(UnalignedHeader firstChunk) {
-        assert VMOperation.isGCInProgress();
+        assert ParallelGC.isEnabled() || VMOperation.isGCInProgress();
         freeUnalignedChunkList(firstChunk);
     }
 
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     private static void zap(Header<?> chunk, WordBase value) {
         Pointer start = HeapChunk.getTopPointer(chunk);
         Pointer limit = HeapChunk.getEndPointer(chunk);
-        log().string("  zap chunk: ").zhex(chunk).string("  start: ").zhex(start).string("  limit: ").zhex(limit).string("  value: ").zhex(value).newline();
         for (Pointer p = start; p.belowThan(limit); p = p.add(FrameAccess.wordSize())) {
             p.writeWord(0, value);
         }
@@ -333,12 +316,14 @@ final class HeapChunkProvider {
         return continueVisiting;
     }
 
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     private void noteFirstAllocationTime() {
         if (firstAllocationTime == 0L) {
             firstAllocationTime = System.nanoTime();
         }
     }
 
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     long getFirstAllocationTime() {
         return firstAllocationTime;
     }
diff --git a/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/HeapImpl.java b/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/HeapImpl.java
index c2e30ce3053..4be5415ffe9 100644
--- a/graal/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/HeapImpl.java
+++ b/graal/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/HeapImpl.java
@@ -58,6 +58,7 @@ import com.oracle.svm.core.genscavenge.AlignedHeapChunk.AlignedHeader;
 import com.oracle.svm.core.genscavenge.ThreadLocalAllocation.Descriptor;
 import com.oracle.svm.core.genscavenge.UnalignedHeapChunk.UnalignedHeader;
 import com.oracle.svm.core.genscavenge.graal.ForcedSerialPostWriteBarrier;
+import com.oracle.svm.core.genscavenge.parallel.ParallelGC;
 import com.oracle.svm.core.graal.snippets.SubstrateAllocationSnippets;
 import com.oracle.svm.core.heap.GC;
 import com.oracle.svm.core.heap.GCCause;
@@ -192,16 +193,13 @@ public final class HeapImpl extends Heap {
         return walkImageHeapObjects(visitor) && walkCollectedHeapObjects(visitor);
     }
 
-    /** Walk the regions of the heap. */
-    boolean walkMemory(MemoryWalker.Visitor visitor) {
-        VMOperation.guaranteeInProgressAtSafepoint("must only be executed at a safepoint");
-        return walkNativeImageHeapRegions(visitor) && getYoungGeneration().walkHeapChunks(visitor) && getOldGeneration().walkHeapChunks(visitor) && getChunkProvider().walkHeapChunks(visitor);
-    }
-
     /** Tear down the heap and release its memory. */
     @Override
     @Uninterruptible(reason = "Tear-down in progress.")
     public boolean tearDown() {
+        if (ParallelGC.isEnabled()) {
+            ParallelGC.singleton().tearDown();
+        }
         youngGeneration.tearDown();
         oldGeneration.tearDown();
         getChunkProvider().tearDown();
@@ -214,14 +212,20 @@ public final class HeapImpl extends Heap {
         return objectHeaderImpl;
     }
 
-    ObjectHeaderImpl getObjectHeaderImpl() {
-        return objectHeaderImpl;
+    @Fold
+    static ObjectHeaderImpl getObjectHeaderImpl() {
+        return getHeapImpl().objectHeaderImpl;
     }
 
     @Fold
     @Override
     public GC getGC() {
-        return getGCImpl();
+        return getHeapImpl().gcImpl;
+    }
+
+    @Fold
+    static GCImpl getGCImpl() {
+        return getHeapImpl().gcImpl;
     }
 
     @Fold
@@ -235,10 +239,6 @@ public final class HeapImpl extends Heap {
         return accounting;
     }
 
-    GCImpl getGCImpl() {
-        return gcImpl;
-    }
-
     @Override
     @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     public boolean isAllocationDisallowed() {
@@ -262,6 +262,7 @@ public final class HeapImpl extends Heap {
         return oldGeneration;
     }
 
+    @Fold
     AtomicReference<PinnedObjectImpl> getPinHead() {
         return pinHead;
     }
@@ -468,11 +469,6 @@ public final class HeapImpl extends Heap {
         return getYoungGeneration().walkObjects(visitor) && getOldGeneration().walkObjects(visitor);
     }
 
-    boolean walkNativeImageHeapRegions(MemoryWalker.ImageHeapRegionVisitor visitor) {
-        return ImageHeapWalker.walkRegions(imageHeapInfo, visitor) &&
-                        (!AuxiliaryImageHeap.isPresent() || AuxiliaryImageHeap.singleton().walkRegions(visitor));
-    }
-
     @Override
     public void doReferenceHandling() {
         if (ReferenceHandler.isExecutedManually()) {
@@ -697,7 +693,7 @@ public final class HeapImpl extends Heap {
 
     @Override
     public long getMillisSinceLastWholeHeapExamined() {
-        return getGCImpl().getMillisSinceLastWholeHeapExamined();
+        return HeapImpl.getGCImpl().getMillisSinceLastWholeHeapExamined();
     }
 
     @Override
@@ -707,9 +703,10 @@ public final class HeapImpl extends Heap {
             assert !isInImageHeap(obj) : "Image heap objects have identity hash code fields";
         }
         HeapChunk.Header<?> chunk = HeapChunk.getEnclosingHeapChunk(obj);
-        return HeapChunk.getIdentityHashSalt(chunk).rawValue();
+        return HeapChunk.getIdentityHashSalt(chunk);
     }
 
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     static Pointer getImageHeapStart() {
         int imageHeapOffsetInAddressSpace = Heap.getHeap().getImageHeapOffsetInAddressSpace();
         if (imageHeapOffsetInAddressSpace > 0) {
diff --git a/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/HeapParameters.java b/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/HeapParameters.java
index 42bb84bf63f..6ec7fecce13 100644
--- a/graal/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/HeapParameters.java
+++ b/graal/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/HeapParameters.java
@@ -142,6 +142,7 @@ public final class HeapParameters {
      * Zapping
      */
 
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     public static boolean getZapProducedHeapChunks() {
         return SerialAndEpsilonGCOptions.ZapChunks.getValue() || SerialAndEpsilonGCOptions.ZapProducedHeapChunks.getValue();
     }
diff --git a/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/ImageHeapInfo.java b/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/ImageHeapInfo.java
index 44d04a7cdd1..4be1beea5a6 100644
--- a/graal/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/ImageHeapInfo.java
+++ b/graal/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/ImageHeapInfo.java
@@ -30,10 +30,10 @@ import org.graalvm.word.UnsignedWord;
 import org.graalvm.word.WordFactory;
 
 import com.oracle.svm.core.Uninterruptible;
-import com.oracle.svm.core.heap.UnknownObjectField;
-import com.oracle.svm.core.heap.UnknownPrimitiveField;
 import com.oracle.svm.core.genscavenge.AlignedHeapChunk.AlignedHeader;
 import com.oracle.svm.core.genscavenge.UnalignedHeapChunk.UnalignedHeader;
+import com.oracle.svm.core.heap.UnknownObjectField;
+import com.oracle.svm.core.heap.UnknownPrimitiveField;
 import com.oracle.svm.core.hub.LayoutEncoding;
 import com.oracle.svm.core.log.Log;
 import com.oracle.svm.core.snippets.KnownIntrinsics;
@@ -187,10 +187,12 @@ public final class ImageHeapInfo {
         return result;
     }
 
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     public AlignedHeader getFirstWritableAlignedChunk() {
         return asImageHeapChunk(offsetOfFirstWritableAlignedChunk);
     }
 
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     public UnalignedHeader getFirstWritableUnalignedChunk() {
         return asImageHeapChunk(offsetOfFirstWritableUnalignedChunk);
     }
@@ -204,6 +206,7 @@ public final class ImageHeapInfo {
     }
 
     @SuppressWarnings("unchecked")
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     private static <T extends HeapChunk.Header<T>> T asImageHeapChunk(long offsetInImageHeap) {
         if (offsetInImageHeap < 0) {
             return (T) WordFactory.nullPointer();
diff --git a/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/ImageHeapWalker.java b/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/ImageHeapWalker.java
index 2c17d3bbf73..9f781524dcd 100644
--- a/graal/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/ImageHeapWalker.java
+++ b/graal/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/ImageHeapWalker.java
@@ -31,8 +31,9 @@ import org.graalvm.word.Pointer;
 import org.graalvm.word.UnsignedWord;
 import org.graalvm.word.WordFactory;
 
-import com.oracle.svm.core.MemoryWalker;
 import com.oracle.svm.core.AlwaysInline;
+import com.oracle.svm.core.MemoryWalker;
+import com.oracle.svm.core.Uninterruptible;
 import com.oracle.svm.core.heap.ObjectVisitor;
 import com.oracle.svm.core.hub.LayoutEncoding;
 import com.oracle.svm.core.os.CommittedMemoryProvider;
@@ -75,11 +76,13 @@ public final class ImageHeapWalker {
     }
 
     @AlwaysInline("GC performance")
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     static boolean walkPartitionInline(Object firstObject, Object lastObject, ObjectVisitor visitor, boolean alignedChunks) {
         return walkPartitionInline(firstObject, lastObject, visitor, alignedChunks, true);
     }
 
     @AlwaysInline("GC performance")
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     private static boolean walkPartitionInline(Object firstObject, Object lastObject, ObjectVisitor visitor, boolean alignedChunks, boolean inlineObjectVisit) {
         if (firstObject == null || lastObject == null) {
             assert firstObject == null && lastObject == null;
@@ -113,10 +116,10 @@ public final class ImageHeapWalker {
             while (current.belowOrEqual(limit)) {
                 Object currentObject = current.toObject();
                 if (inlineObjectVisit) {
-                    if (!visitor.visitObjectInline(currentObject)) {
+                    if (!visitObjectInline(visitor, currentObject)) {
                         return false;
                     }
-                } else if (!visitor.visitObject(currentObject)) {
+                } else if (!visitObject(visitor, currentObject)) {
                     return false;
                 }
                 current = LayoutEncoding.getImageHeapObjectEnd(current.toObject());
@@ -130,6 +133,16 @@ public final class ImageHeapWalker {
         } while (current.belowOrEqual(lastPointer));
         return true;
     }
+
+    @Uninterruptible(reason = "Bridge between uninterruptible and potentially interruptible code.", mayBeInlined = true, calleeMustBe = false)
+    private static boolean visitObject(ObjectVisitor visitor, Object currentObject) {
+        return visitor.visitObject(currentObject);
+    }
+
+    @Uninterruptible(reason = "Bridge between uninterruptible and potentially interruptible code.", mayBeInlined = true, calleeMustBe = false)
+    private static boolean visitObjectInline(ObjectVisitor visitor, Object currentObject) {
+        return visitor.visitObjectInline(currentObject);
+    }
 }
 
 abstract class MemoryWalkerAccessBase implements MemoryWalker.NativeImageHeapRegionAccess<ImageHeapInfo> {
diff --git a/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/IncrementalGarbageCollectorMXBean.java b/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/IncrementalGarbageCollectorMXBean.java
index 7c08b40086b..f11508e80d0 100644
--- a/graal/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/IncrementalGarbageCollectorMXBean.java
+++ b/graal/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/IncrementalGarbageCollectorMXBean.java
@@ -48,12 +48,12 @@ public final class IncrementalGarbageCollectorMXBean implements com.sun.manageme
 
     @Override
     public long getCollectionCount() {
-        return HeapImpl.getHeapImpl().getGCImpl().getAccounting().getIncrementalCollectionCount();
+        return HeapImpl.getGCImpl().getAccounting().getIncrementalCollectionCount();
     }
 
     @Override
     public long getCollectionTime() {
-        long nanos = HeapImpl.getHeapImpl().getGCImpl().getAccounting().getIncrementalCollectionTotalNanos();
+        long nanos = HeapImpl.getGCImpl().getAccounting().getIncrementalCollectionTotalNanos();
         return TimeUtils.roundNanosToMillis(nanos);
     }
 
diff --git a/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/JfrGCEventSupport.java b/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/JfrGCEventSupport.java
index 47126cddf9e..54965f7a338 100644
--- a/graal/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/JfrGCEventSupport.java
+++ b/graal/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/JfrGCEventSupport.java
@@ -54,11 +54,13 @@ class JfrGCEventSupport {
         this.gcName = gcName;
     }
 
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     public long startGCPhasePause() {
         pushPhase();
         return JfrTicks.elapsedTicks();
     }
 
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     public int stopGCPhasePause() {
         return popPhase();
     }
@@ -124,6 +126,7 @@ class JfrGCEventSupport {
         }
     }
 
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     private void pushPhase() {
         assert currentPhase < MAX_PHASE_LEVEL;
         currentPhase++;
@@ -140,7 +143,7 @@ class JfrGCEventSupport {
 class JfrGCEventFeature implements InternalFeature {
     @Override
     public boolean isInConfiguration(IsInConfigurationAccess access) {
-        return SubstrateOptions.UseSerialGC.getValue();
+        return SubstrateOptions.useSerialOrParallelGC();
     }
 
     @Override
diff --git a/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/JfrGCEvents.java b/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/JfrGCEvents.java
index 63eb13e1ee8..9bcd47d1cac 100644
--- a/graal/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/JfrGCEvents.java
+++ b/graal/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/JfrGCEvents.java
@@ -28,9 +28,11 @@ import org.graalvm.compiler.api.replacements.Fold;
 import org.graalvm.nativeimage.ImageSingletons;
 import org.graalvm.word.UnsignedWord;
 
+import com.oracle.svm.core.Uninterruptible;
 import com.oracle.svm.core.heap.GCCause;
 
 class JfrGCEvents {
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     public static long startGCPhasePause() {
         if (hasJfrSupport()) {
             return jfrSupport().startGCPhasePause();
@@ -38,6 +40,7 @@ class JfrGCEvents {
         return 0;
     }
 
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     public static void emitGCPhasePauseEvent(UnsignedWord gcEpoch, String name, long start) {
         if (hasJfrSupport()) {
             int level = jfrSupport().stopGCPhasePause();
diff --git a/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/ObjectHeaderImpl.java b/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/ObjectHeaderImpl.java
index 1ffadd77743..e93bc5b1bbe 100644
--- a/graal/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/ObjectHeaderImpl.java
+++ b/graal/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/ObjectHeaderImpl.java
@@ -95,7 +95,7 @@ public final class ObjectHeaderImpl extends ObjectHeader {
         } else {
             VMError.guarantee(ReferenceAccess.singleton().haveCompressedReferences(), "Ensures hubs (at the start of the image heap) remain addressable");
             numReservedBits = numMinimumReservedBits + 2;
-            VMError.guarantee(numReservedBits <= numAlignmentBits || ReferenceAccess.singleton().getCompressEncoding().hasShift(),
+            VMError.guarantee(numReservedBits <= numAlignmentBits || hasShift(),
                             "With no shift, forwarding references are stored directly in the header (with 64-bit, must be) and we cannot use non-alignment header bits");
         }
         numReservedExtraBits = numReservedBits - numAlignmentBits;
@@ -104,7 +104,7 @@ public final class ObjectHeaderImpl extends ObjectHeader {
 
     @Fold
     public static ObjectHeaderImpl getObjectHeaderImpl() {
-        ObjectHeaderImpl oh = HeapImpl.getHeapImpl().getObjectHeaderImpl();
+        ObjectHeaderImpl oh = HeapImpl.getObjectHeaderImpl();
         assert oh != null;
         return oh;
     }
@@ -209,6 +209,7 @@ public final class ObjectHeaderImpl extends ObjectHeader {
         return header.and(IDHASH_STATE_BITS).equal(inFieldState);
     }
 
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     void setIdentityHashInField(Object o) {
         assert VMOperation.isGCInProgress();
         VMError.guarantee(!hasFixedIdentityHashField());
@@ -340,8 +341,7 @@ public final class ObjectHeaderImpl extends ObjectHeader {
         VMError.guarantee((header >>> numReservedExtraBits) == hubOffsetFromHeapBase, "Hub is too far from heap base for encoding in object header");
         assert (header & reservedBitsMask) == 0 : "Object header bits must be zero initially";
         if (HeapImpl.usesImageHeapCardMarking()) {
-            if (obj.getPartition() instanceof ChunkedImageHeapPartition) {
-                ChunkedImageHeapPartition partition = (ChunkedImageHeapPartition) obj.getPartition();
+            if (obj.getPartition() instanceof ChunkedImageHeapPartition partition) {
                 if (partition.isWritable()) {
                     header |= REMEMBERED_SET_BIT.rawValue();
                 }
@@ -363,6 +363,7 @@ public final class ObjectHeaderImpl extends ObjectHeader {
         return !isUnalignedObject(o);
     }
 
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     public static boolean isAlignedHeader(UnsignedWord header) {
         return !isUnalignedHeader(header);
     }
@@ -378,12 +379,19 @@ public final class ObjectHeaderImpl extends ObjectHeader {
         return header.and(UNALIGNED_BIT).notEqual(0);
     }
 
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     public static void setRememberedSetBit(Object o) {
         UnsignedWord oldHeader = readHeaderFromObject(o);
         UnsignedWord newHeader = oldHeader.or(REMEMBERED_SET_BIT);
         writeHeaderToObject(o, newHeader);
     }
 
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
+    static long setRememberedSetBit(long headerBytes) {
+        return headerBytes | REMEMBERED_SET_BIT.rawValue();
+    }
+
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     public static boolean hasRememberedSet(UnsignedWord header) {
         return header.and(REMEMBERED_SET_BIT).notEqual(0);
     }
@@ -399,14 +407,11 @@ public final class ObjectHeaderImpl extends ObjectHeader {
         return header.and(FORWARDED_BIT).notEqual(0);
     }
 
-    Object getForwardedObject(Pointer ptr) {
-        return getForwardedObject(ptr, readHeaderFromPointer(ptr));
-    }
-
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     Object getForwardedObject(Pointer ptr, UnsignedWord header) {
         assert isForwardedHeader(header);
         if (ReferenceAccess.singleton().haveCompressedReferences()) {
-            if (ReferenceAccess.singleton().getCompressEncoding().hasShift()) {
+            if (hasShift()) {
                 // References compressed with shift have no bits to spare, so the forwarding
                 // reference is stored separately, after the object header
                 ObjectLayout layout = ConfigurationValues.getObjectLayout();
@@ -423,24 +428,51 @@ public final class ObjectHeaderImpl extends ObjectHeader {
 
     /** In an Object, install a forwarding pointer to a different Object. */
     @AlwaysInline("GC performance")
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     void installForwardingPointer(Object original, Object copy) {
         assert !isPointerToForwardedObject(Word.objectToUntrackedPointer(original));
-        UnsignedWord forwardHeader;
+        UnsignedWord forwardHeader = getForwardHeader(copy);
+        ObjectAccess.writeLong(original, getHubOffset(), forwardHeader.rawValue());
+        assert isPointerToForwardedObject(Word.objectToUntrackedPointer(original));
+    }
+
+    /**
+     * The original header are the 8 bytes at the hub offset (regardless if compressed references
+     * are used or not).
+     */
+    @AlwaysInline("GC performance")
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
+    Object installForwardingPointerParallel(Object original, long eightHeaderBytes, Object copy) {
+        UnsignedWord forwardHeader = getForwardHeader(copy);
+        /* Try installing the new header. */
+        Pointer originalPtr = Word.objectToUntrackedPointer(original);
+        long value = originalPtr.compareAndSwapLong(getHubOffset(), eightHeaderBytes, forwardHeader.rawValue(), LocationIdentity.ANY_LOCATION);
+        assert isPointerToForwardedObject(originalPtr);
+        if (value != eightHeaderBytes) {
+            return getForwardedObject(originalPtr, WordFactory.unsigned(value));
+        }
+        return copy;
+    }
+
+    @AlwaysInline("GC performance")
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
+    private UnsignedWord getForwardHeader(Object copy) {
+        UnsignedWord result;
         if (ReferenceAccess.singleton().haveCompressedReferences()) {
-            if (ReferenceAccess.singleton().getCompressEncoding().hasShift()) {
+            UnsignedWord compressedCopy = ReferenceAccess.singleton().getCompressedRepresentation(copy);
+            if (hasShift()) {
                 // Compression with a shift uses all bits of a reference, so store the forwarding
                 // pointer in the location following the hub pointer.
-                forwardHeader = WordFactory.unsigned(0xe0e0e0e0e0e0e0e0L);
-                ObjectAccess.writeObject(original, getHubOffset() + getReferenceSize(), copy);
+                result = compressedCopy.shiftLeft(32).or(WordFactory.unsigned(0x00000000e0e0e0e0L));
             } else {
-                forwardHeader = ReferenceAccess.singleton().getCompressedRepresentation(copy);
+                result = compressedCopy;
             }
         } else {
-            forwardHeader = Word.objectToUntrackedPointer(copy);
+            result = Word.objectToUntrackedPointer(copy);
         }
-        assert getHeaderBitsFromHeader(forwardHeader).equal(0);
-        writeHeaderToObject(original, forwardHeader.or(FORWARDED_BIT));
-        assert isPointerToForwardedObject(Word.objectToUntrackedPointer(original));
+
+        assert getHeaderBitsFromHeader(result).equal(0);
+        return result.or(FORWARDED_BIT);
     }
 
     @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
@@ -450,6 +482,11 @@ public final class ObjectHeaderImpl extends ObjectHeader {
         return header.and(reservedBitsMask);
     }
 
+    @Fold
+    static boolean hasShift() {
+        return ReferenceAccess.singleton().getCompressEncoding().hasShift();
+    }
+
     @Fold
     static int getHubOffset() {
         return ConfigurationValues.getObjectLayout().getHubOffset();
diff --git a/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/OldGeneration.java b/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/OldGeneration.java
index 395e39ef03f..fb2dfefc6ed 100644
--- a/graal/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/OldGeneration.java
+++ b/graal/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/OldGeneration.java
@@ -31,10 +31,11 @@ import org.graalvm.nativeimage.Platform;
 import org.graalvm.nativeimage.Platforms;
 import org.graalvm.word.UnsignedWord;
 
-import com.oracle.svm.core.MemoryWalker;
 import com.oracle.svm.core.AlwaysInline;
+import com.oracle.svm.core.MemoryWalker;
 import com.oracle.svm.core.Uninterruptible;
 import com.oracle.svm.core.genscavenge.GCImpl.ChunkReleaser;
+import com.oracle.svm.core.genscavenge.parallel.ParallelGC;
 import com.oracle.svm.core.genscavenge.remset.RememberedSet;
 import com.oracle.svm.core.heap.ObjectVisitor;
 import com.oracle.svm.core.log.Log;
@@ -73,40 +74,44 @@ public final class OldGeneration extends Generation {
 
     /** Promote an Object to ToSpace if it is not already in ToSpace. */
     @AlwaysInline("GC performance")
-    @Override
-    public Object promoteAlignedObject(Object original, AlignedHeapChunk.AlignedHeader originalChunk, Space originalSpace) {
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
+    Object promoteAlignedObject(Object original, Space originalSpace) {
         assert originalSpace.isFromSpace();
         return getToSpace().promoteAlignedObject(original, originalSpace);
     }
 
     @AlwaysInline("GC performance")
-    @Override
-    protected Object promoteUnalignedObject(Object original, UnalignedHeapChunk.UnalignedHeader originalChunk, Space originalSpace) {
-        assert originalSpace.isFromSpace();
-        getToSpace().promoteUnalignedHeapChunk(originalChunk, originalSpace);
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
+    Object promoteUnalignedObject(Object original, UnalignedHeapChunk.UnalignedHeader originalChunk) {
+        getToSpace().promoteUnalignedHeapChunk(originalChunk);
         return original;
     }
 
-    @Override
-    protected boolean promoteChunk(HeapChunk.Header<?> originalChunk, boolean isAligned, Space originalSpace) {
-        assert originalSpace.isFromSpace();
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
+    void promoteChunk(HeapChunk.Header<?> originalChunk, boolean isAligned) {
         if (isAligned) {
-            getToSpace().promoteAlignedHeapChunk((AlignedHeapChunk.AlignedHeader) originalChunk, originalSpace);
+            getToSpace().promoteAlignedHeapChunk((AlignedHeapChunk.AlignedHeader) originalChunk);
         } else {
-            getToSpace().promoteUnalignedHeapChunk((UnalignedHeapChunk.UnalignedHeader) originalChunk, originalSpace);
+            getToSpace().promoteUnalignedHeapChunk((UnalignedHeapChunk.UnalignedHeader) originalChunk);
         }
-        return true;
     }
 
     void releaseSpaces(ChunkReleaser chunkReleaser) {
         getFromSpace().releaseChunks(chunkReleaser);
     }
 
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     void prepareForPromotion() {
+        if (ParallelGC.isEnabled()) {
+            return;
+        }
         toGreyObjectsWalker.setScanStart(getToSpace());
     }
 
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     boolean scanGreyObjects() {
+        assert !ParallelGC.isEnabled();
+
         if (!toGreyObjectsWalker.haveGreyObjects()) {
             return false;
         }
@@ -139,6 +144,7 @@ public final class OldGeneration extends Generation {
     }
 
     /* Extract all the HeapChunks from FromSpace and append them to ToSpace. */
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     void emptyFromSpaceIntoToSpace() {
         getToSpace().absorb(getFromSpace());
     }
@@ -158,13 +164,13 @@ public final class OldGeneration extends Generation {
         return fromBytes.add(toBytes);
     }
 
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     @SuppressWarnings("static-method")
     AlignedHeapChunk.AlignedHeader requestAlignedChunk() {
         assert VMOperation.isGCInProgress() : "Should only be called from the collector.";
         AlignedHeapChunk.AlignedHeader chunk = HeapImpl.getChunkProvider().produceAlignedChunk();
         if (probability(EXTREMELY_SLOW_PATH_PROBABILITY, chunk.isNull())) {
-            Log.log().string("[! OldGeneration.requestAlignedChunk: failure to allocate aligned chunk!]");
-            throw VMError.shouldNotReachHere("Promotion failure");
+            throw VMError.shouldNotReachHere("OldGeneration.requestAlignedChunk: failure to allocate aligned chunk");
         }
         RememberedSet.get().enableRememberedSetForChunk(chunk);
         return chunk;
diff --git a/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/PinnedObjectImpl.java b/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/PinnedObjectImpl.java
index f58a5b91077..e6cb7a75995 100644
--- a/graal/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/PinnedObjectImpl.java
+++ b/graal/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/PinnedObjectImpl.java
@@ -76,12 +76,14 @@ final class PinnedObjectImpl implements PinnedObject {
         } while (!pinHead.compareAndSet(sampleHead, newHead));
     }
 
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     static PinnedObjectImpl getPinnedObjects() {
         assert VMOperation.isGCInProgress();
         UninterruptibleUtils.AtomicReference<PinnedObjectImpl> pinHead = HeapImpl.getHeapImpl().getPinHead();
         return pinHead.get();
     }
 
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     static void setPinnedObjects(PinnedObjectImpl list) {
         assert VMOperation.isGCInProgress();
         UninterruptibleUtils.AtomicReference<PinnedObjectImpl> pinHead = HeapImpl.getHeapImpl().getPinHead();
@@ -107,6 +109,7 @@ final class PinnedObjectImpl implements PinnedObject {
     }
 
     @Override
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     public Object getObject() {
         assert open : "Should not call getObject() on a closed PinnedObject.";
         return referent;
@@ -129,14 +132,17 @@ final class PinnedObjectImpl implements PinnedObject {
         return (T) addressOfObject().add(offsetOfArrayElement);
     }
 
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     public boolean isOpen() {
         return open;
     }
 
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     public PinnedObjectImpl getNext() {
         return next;
     }
 
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     void setNext(PinnedObjectImpl value) {
         // Avoid useless writes as those would dirty the card table unnecessarily.
         if (value != next) {
diff --git a/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/ReferenceObjectProcessing.java b/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/ReferenceObjectProcessing.java
index 429afe8fa0b..a8233f23cc1 100644
--- a/graal/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/ReferenceObjectProcessing.java
+++ b/graal/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/ReferenceObjectProcessing.java
@@ -36,11 +36,13 @@ import org.graalvm.word.UnsignedWord;
 import org.graalvm.word.WordFactory;
 
 import com.oracle.svm.core.AlwaysInline;
+import com.oracle.svm.core.Uninterruptible;
 import com.oracle.svm.core.genscavenge.remset.RememberedSet;
 import com.oracle.svm.core.heap.Heap;
 import com.oracle.svm.core.heap.ObjectReferenceVisitor;
 import com.oracle.svm.core.heap.ReferenceInternals;
 import com.oracle.svm.core.hub.DynamicHub;
+import com.oracle.svm.core.jdk.UninterruptibleUtils.AtomicReference;
 import com.oracle.svm.core.snippets.KnownIntrinsics;
 import com.oracle.svm.core.thread.VMOperation;
 import com.oracle.svm.core.util.UnsignedUtils;
@@ -48,7 +50,7 @@ import com.oracle.svm.core.util.UnsignedUtils;
 /** Discovers and handles {@link Reference} objects during garbage collection. */
 final class ReferenceObjectProcessing {
     /** Head of the linked list of discovered references that need to be revisited. */
-    private static Reference<?> rememberedRefsList;
+    private static final AtomicReference<Reference<?>> rememberedRefsList = new AtomicReference<>();
 
     /**
      * For a {@link SoftReference}, the longest duration after its last access to keep its referent
@@ -78,6 +80,7 @@ final class ReferenceObjectProcessing {
     }
 
     @AlwaysInline("GC performance")
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     public static void discoverIfReference(Object object, ObjectReferenceVisitor refVisitor) {
         assert object != null;
         DynamicHub hub = KnownIntrinsics.readHub(object);
@@ -86,6 +89,8 @@ final class ReferenceObjectProcessing {
         }
     }
 
+    @AlwaysInline("GC performance")
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     private static void discover(Object obj, ObjectReferenceVisitor refVisitor) {
         Reference<?> dr = (Reference<?>) obj;
         // The discovered field might contain an object with a forwarding header
@@ -108,17 +113,22 @@ final class ReferenceObjectProcessing {
             // Referents in the image heap cannot be moved or reclaimed, no need to look closer.
             return;
         }
-        if (maybeUpdateForwardedReference(dr, referentAddr)) {
+
+        /*
+         * The parallel GC may modify the object header at any time, so we only read the object
+         * header once.
+         */
+        UnsignedWord referentHeader = ObjectHeaderImpl.getObjectHeaderImpl().readHeaderFromPointer(referentAddr);
+        if (maybeUpdateForwardedReference(dr, referentAddr, referentHeader)) {
             // Some other object had a strong reference to the referent, so the referent was already
             // promoted. The call above updated the reference object so that it now points to the
             // promoted object.
             return;
         }
-        Object refObject = referentAddr.toObject();
-        if (willSurviveThisCollection(refObject)) {
+        if (willSurviveThisCollection(referentAddr, referentHeader)) {
             // Referent is in a to-space. So, this is either an object that got promoted without
             // being moved or an object in the old gen.
-            RememberedSet.get().dirtyCardIfNecessary(dr, refObject);
+            RememberedSet.get().dirtyCardIfNecessary(dr, referentAddr.toObject());
             return;
         }
         if (!softReferencesAreWeak && dr instanceof SoftReference) {
@@ -141,9 +151,11 @@ final class ReferenceObjectProcessing {
         // are revisited after the GC finished promoting all strongly reachable objects.
 
         // null link means undiscovered, avoid for the last node with a cyclic reference
-        Reference<?> next = (rememberedRefsList != null) ? rememberedRefsList : dr;
-        ReferenceInternals.setNextDiscovered(dr, next);
-        rememberedRefsList = dr;
+        Reference<?> expected;
+        do {
+            expected = rememberedRefsList.get();
+            ReferenceInternals.setNextDiscovered(dr, expected != null ? expected : dr);
+        } while (!rememberedRefsList.compareAndSet(expected, dr));
     }
 
     /**
@@ -154,8 +166,7 @@ final class ReferenceObjectProcessing {
      */
     static Reference<?> processRememberedReferences() {
         Reference<?> pendingHead = null;
-        Reference<?> current = rememberedRefsList;
-        rememberedRefsList = null;
+        Reference<?> current = rememberedRefsList.getAndSet(null);
 
         while (current != null) {
             // Get the next node (the last node has a cyclic reference to self).
@@ -180,7 +191,7 @@ final class ReferenceObjectProcessing {
     }
 
     static void afterCollection(UnsignedWord freeBytes) {
-        assert rememberedRefsList == null;
+        assert rememberedRefsList.get() == null;
         UnsignedWord unused = freeBytes.unsignedDivide(1024 * 1024 /* MB */);
         maxSoftRefAccessIntervalMs = unused.multiply(SerialGCOptions.SoftRefLRUPolicyMSPerMB.getValue());
         ReferenceInternals.updateSoftReferenceClock();
@@ -198,12 +209,13 @@ final class ReferenceObjectProcessing {
         Pointer refPointer = ReferenceInternals.getReferentPointer(dr);
         assert refPointer.isNonNull() : "Referent is null: should not have been discovered";
         assert !HeapImpl.getHeapImpl().isInImageHeap(refPointer) : "Image heap referent: should not have been discovered";
-        if (maybeUpdateForwardedReference(dr, refPointer)) {
+
+        UnsignedWord refHeader = ObjectHeaderImpl.getObjectHeaderImpl().readHeaderFromPointer(refPointer);
+        if (maybeUpdateForwardedReference(dr, refPointer, refHeader)) {
             return true;
         }
-        Object refObject = refPointer.toObject();
-        if (willSurviveThisCollection(refObject)) {
-            RememberedSet.get().dirtyCardIfNecessary(dr, refObject);
+        if (willSurviveThisCollection(refPointer, refHeader)) {
+            RememberedSet.get().dirtyCardIfNecessary(dr, refPointer.toObject());
             return true;
         }
         /*
@@ -217,20 +229,20 @@ final class ReferenceObjectProcessing {
         return false;
     }
 
-    private static boolean maybeUpdateForwardedReference(Reference<?> dr, Pointer referentAddr) {
-        ObjectHeaderImpl ohi = ObjectHeaderImpl.getObjectHeaderImpl();
-        UnsignedWord header = ohi.readHeaderFromPointer(referentAddr);
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
+    private static boolean maybeUpdateForwardedReference(Reference<?> dr, Pointer referentAddr, UnsignedWord header) {
         if (ObjectHeaderImpl.isForwardedHeader(header)) {
-            Object forwardedObj = ohi.getForwardedObject(referentAddr);
+            Object forwardedObj = ObjectHeaderImpl.getObjectHeaderImpl().getForwardedObject(referentAddr, header);
             ReferenceInternals.setReferent(dr, forwardedObj);
             return true;
         }
         return false;
     }
 
-    private static boolean willSurviveThisCollection(Object obj) {
-        HeapChunk.Header<?> chunk = HeapChunk.getEnclosingHeapChunk(obj);
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
+    private static boolean willSurviveThisCollection(Pointer ptr, UnsignedWord header) {
+        HeapChunk.Header<?> chunk = HeapChunk.getEnclosingHeapChunk(ptr, header);
         Space space = HeapChunk.getSpace(chunk);
-        return !space.isFromSpace();
+        return space != null && !space.isFromSpace();
     }
 }
diff --git a/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/SerialAndEpsilonGCOptions.java b/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/SerialAndEpsilonGCOptions.java
index b52a5f40570..463178a8403 100644
--- a/graal/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/SerialAndEpsilonGCOptions.java
+++ b/graal/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/SerialAndEpsilonGCOptions.java
@@ -36,16 +36,17 @@ import com.oracle.svm.core.option.RuntimeOptionKey;
 import com.oracle.svm.core.util.InterruptImageBuilding;
 import com.oracle.svm.core.util.UserError;
 
-/** Common options that can be specified for both the serial and the epsilon GC. */
+/** Options that can be specified for the serial, the parallel, and the epsilon GC. */
+// TODO (chaeubl): rename
 public final class SerialAndEpsilonGCOptions {
-    @Option(help = "The maximum heap size as percent of physical memory. Serial and epsilon GC only.", type = OptionType.User) //
-    public static final RuntimeOptionKey<Integer> MaximumHeapSizePercent = new NotifyGCRuntimeOptionKey<>(80, SerialAndEpsilonGCOptions::serialOrEpsilonGCOnly);
+    @Option(help = "The maximum heap size as percent of physical memory. Serial, parallel, and epsilon GC only.", type = OptionType.User) //
+    public static final RuntimeOptionKey<Integer> MaximumHeapSizePercent = new NotifyGCRuntimeOptionKey<>(80, SerialAndEpsilonGCOptions::serialOrParallelOrEpsilonGCOnly);
 
-    @Option(help = "The maximum size of the young generation as a percentage of the maximum heap size. Serial and epsilon GC only.", type = OptionType.User) //
-    public static final RuntimeOptionKey<Integer> MaximumYoungGenerationSizePercent = new NotifyGCRuntimeOptionKey<>(10, SerialAndEpsilonGCOptions::serialOrEpsilonGCOnly);
+    @Option(help = "The maximum size of the young generation as a percentage of the maximum heap size. Serial, parallel, and epsilon GC only.", type = OptionType.User) //
+    public static final RuntimeOptionKey<Integer> MaximumYoungGenerationSizePercent = new NotifyGCRuntimeOptionKey<>(10, SerialAndEpsilonGCOptions::serialOrParallelOrEpsilonGCOnly);
 
-    @Option(help = "The size of an aligned chunk. Serial and epsilon GC only.", type = OptionType.Expert) //
-    public static final HostedOptionKey<Long> AlignedHeapChunkSize = new HostedOptionKey<>(1L * 1024L * 1024L, SerialAndEpsilonGCOptions::serialOrEpsilonGCOnly) {
+    @Option(help = "The size of an aligned chunk. Serial, parallel, and epsilon GC only.", type = OptionType.Expert) //
+    public static final HostedOptionKey<Long> AlignedHeapChunkSize = new HostedOptionKey<>(1L * 1024L * 1024L, SerialAndEpsilonGCOptions::serialOrParallelOrEpsilonGCOnly) {
         @Override
         protected void onValueUpdate(EconomicMap<OptionKey<?>, Object> values, Long oldValue, Long newValue) {
             int multiple = 4096;
@@ -57,28 +58,29 @@ public final class SerialAndEpsilonGCOptions {
      * This should be a fraction of the size of an aligned chunk, else large small arrays will not
      * fit in an aligned chunk.
      */
-    @Option(help = "The size at or above which an array will be allocated in its own unaligned chunk. 0 implies (AlignedHeapChunkSize / 8). Serial and epsilon GC only.", type = OptionType.Expert) //
-    public static final HostedOptionKey<Long> LargeArrayThreshold = new HostedOptionKey<>(0L, SerialAndEpsilonGCOptions::serialOrEpsilonGCOnly);
+    @Option(help = "The size at or above which an array will be allocated in its own unaligned chunk. 0 implies (AlignedHeapChunkSize / 8). Serial, parallel, and epsilon GC only.", type = OptionType.Expert) //
+    public static final HostedOptionKey<Long> LargeArrayThreshold = new HostedOptionKey<>(0L, SerialAndEpsilonGCOptions::serialOrParallelOrEpsilonGCOnly);
 
-    @Option(help = "Fill unused memory chunks with a sentinel value. Serial and epsilon GC only.", type = OptionType.Debug) //
-    public static final HostedOptionKey<Boolean> ZapChunks = new HostedOptionKey<>(false, SerialAndEpsilonGCOptions::serialOrEpsilonGCOnly);
+    @Option(help = "Fill unused memory chunks with a sentinel value. Serial, parallel, and epsilon GC only.", type = OptionType.Debug) //
+    public static final HostedOptionKey<Boolean> ZapChunks = new HostedOptionKey<>(false, SerialAndEpsilonGCOptions::serialOrParallelOrEpsilonGCOnly);
 
-    @Option(help = "Before use, fill memory chunks with a sentinel value. Serial and epsilon GC only.", type = OptionType.Debug) //
-    public static final HostedOptionKey<Boolean> ZapProducedHeapChunks = new HostedOptionKey<>(false, SerialAndEpsilonGCOptions::serialOrEpsilonGCOnly);
+    @Option(help = "Before use, fill memory chunks with a sentinel value. Serial, parallel, and epsilon GC only.", type = OptionType.Debug) //
+    public static final HostedOptionKey<Boolean> ZapProducedHeapChunks = new HostedOptionKey<>(false, SerialAndEpsilonGCOptions::serialOrParallelOrEpsilonGCOnly);
 
-    @Option(help = "After use, Fill memory chunks with a sentinel value. Serial and epsilon GC only.", type = OptionType.Debug) //
-    public static final HostedOptionKey<Boolean> ZapConsumedHeapChunks = new HostedOptionKey<>(false, SerialAndEpsilonGCOptions::serialOrEpsilonGCOnly);
+    @Option(help = "After use, Fill memory chunks with a sentinel value. Serial, parallel, and epsilon GC only.", type = OptionType.Debug) //
+    public static final HostedOptionKey<Boolean> ZapConsumedHeapChunks = new HostedOptionKey<>(false, SerialAndEpsilonGCOptions::serialOrParallelOrEpsilonGCOnly);
 
-    @Option(help = "Number of bytes at the beginning of each heap chunk that are not used for payload data, i.e., can be freely used as metadata by the heap chunk provider. Serial and epsilon GC only.", type = OptionType.Debug) //
-    public static final HostedOptionKey<Integer> HeapChunkHeaderPadding = new HostedOptionKey<>(0, SerialAndEpsilonGCOptions::serialOrEpsilonGCOnly);
+    @Option(help = "Number of bytes at the beginning of each heap chunk that are not used for payload data, i.e., can be freely used as metadata by the heap chunk provider. Serial, parallel, and epsilon GC only.", type = OptionType.Debug) //
+    public static final HostedOptionKey<Integer> HeapChunkHeaderPadding = new HostedOptionKey<>(0, SerialAndEpsilonGCOptions::serialOrParallelOrEpsilonGCOnly);
 
     private SerialAndEpsilonGCOptions() {
     }
 
-    public static void serialOrEpsilonGCOnly(OptionKey<?> optionKey) {
-        if (!SubstrateOptions.UseSerialGC.getValue() && !SubstrateOptions.UseEpsilonGC.getValue()) {
+    public static void serialOrParallelOrEpsilonGCOnly(OptionKey<?> optionKey) {
+        if (!SubstrateOptions.useSerialOrParallelOrEpsilonGC()) {
             throw new InterruptImageBuilding(
-                            "The option '" + optionKey.getName() + "' can only be used together with the serial ('--gc=serial') or the epsilon garbage collector ('--gc=epsilon').");
+                            "The option '" + optionKey.getName() +
+                                            "' can only be used together with the serial ('--gc=serial'), parallel ('--gc=parallel'), or the epsilon garbage collector ('--gc=epsilon').");
         }
     }
 }
diff --git a/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/SerialGCOptions.java b/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/SerialGCOptions.java
index bc23ae04dc9..c94a10c81b6 100644
--- a/graal/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/SerialGCOptions.java
+++ b/graal/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/SerialGCOptions.java
@@ -36,19 +36,20 @@ import com.oracle.svm.core.option.RuntimeOptionKey;
 import com.oracle.svm.core.util.InterruptImageBuilding;
 import com.oracle.svm.core.util.UserError;
 
-/** Options that are only valid for the serial GC (and not for the epsilon GC). */
+/** Options that can be specified for the serial and the parallel GC. */
+// TODO (chaeubl): rename this class
 public final class SerialGCOptions {
-    @Option(help = "The garbage collection policy, either Adaptive (default) or BySpaceAndTime. Serial GC only.", type = OptionType.User)//
-    public static final HostedOptionKey<String> InitialCollectionPolicy = new HostedOptionKey<>("Adaptive", SerialGCOptions::serialGCOnly);
+    @Option(help = "The garbage collection policy, either Adaptive (default) or BySpaceAndTime. Serial and parallel GC only.", type = OptionType.User)//
+    public static final HostedOptionKey<String> InitialCollectionPolicy = new HostedOptionKey<>("Adaptive", SerialGCOptions::serialOrParallelGCOnly);
 
-    @Option(help = "Percentage of total collection time that should be spent on young generation collections. Serial GC with collection policy 'BySpaceAndTime' only.", type = OptionType.User)//
-    public static final RuntimeOptionKey<Integer> PercentTimeInIncrementalCollection = new RuntimeOptionKey<>(50, SerialGCOptions::serialGCOnly);
+    @Option(help = "Percentage of total collection time that should be spent on young generation collections. Serial and parallel GC only, if the collection policy 'BySpaceAndTime' is used.", type = OptionType.User)//
+    public static final RuntimeOptionKey<Integer> PercentTimeInIncrementalCollection = new RuntimeOptionKey<>(50, SerialGCOptions::serialOrParallelGCOnly);
 
-    @Option(help = "The maximum free bytes reserved for allocations, in bytes (0 for automatic according to GC policy). Serial GC only.", type = OptionType.User)//
-    public static final RuntimeOptionKey<Long> MaxHeapFree = new RuntimeOptionKey<>(0L, SerialGCOptions::serialGCOnly);
+    @Option(help = "The maximum free bytes reserved for allocations, in bytes (0 for automatic according to GC policy). Serial and parallel GC only.", type = OptionType.User)//
+    public static final RuntimeOptionKey<Long> MaxHeapFree = new RuntimeOptionKey<>(0L, SerialGCOptions::serialOrParallelGCOnly);
 
-    @Option(help = "Maximum number of survivor spaces. Serial GC only.", type = OptionType.Expert) //
-    public static final HostedOptionKey<Integer> MaxSurvivorSpaces = new HostedOptionKey<>(null, SerialGCOptions::serialGCOnly) {
+    @Option(help = "Maximum number of survivor spaces. Serial and parallel GC only.", type = OptionType.Expert) //
+    public static final HostedOptionKey<Integer> MaxSurvivorSpaces = new HostedOptionKey<>(null, SerialGCOptions::serialOrParallelGCOnly) {
         @Override
         public Integer getValueOrDefault(UnmodifiableEconomicMap<OptionKey<?>, Object> values) {
             Integer value = (Integer) values.get(this);
@@ -63,52 +64,52 @@ public final class SerialGCOptions {
         }
     };
 
-    @Option(help = "Determines if a full GC collects the young generation separately or together with the old generation. Serial GC only.", type = OptionType.Expert) //
-    public static final RuntimeOptionKey<Boolean> CollectYoungGenerationSeparately = new RuntimeOptionKey<>(null, SerialGCOptions::serialGCOnly);
+    @Option(help = "Determines if a full GC collects the young generation separately or together with the old generation. Serial and parallel GC only.", type = OptionType.Expert) //
+    public static final RuntimeOptionKey<Boolean> CollectYoungGenerationSeparately = new RuntimeOptionKey<>(null, SerialGCOptions::serialOrParallelGCOnly);
 
-    @Option(help = "Enables card marking for image heap objects, which arranges them in chunks. Automatically enabled when supported. Serial GC only.", type = OptionType.Expert) //
-    public static final HostedOptionKey<Boolean> ImageHeapCardMarking = new HostedOptionKey<>(null, SerialGCOptions::serialGCOnly);
+    @Option(help = "Enables card marking for image heap objects, which arranges them in chunks. Automatically enabled when supported. Serial and parallel GC only.", type = OptionType.Expert) //
+    public static final HostedOptionKey<Boolean> ImageHeapCardMarking = new HostedOptionKey<>(null, SerialGCOptions::serialOrParallelGCOnly);
 
     @Option(help = "This number of milliseconds multiplied by the free heap memory in MByte is the time span " +
-                    "for which a soft reference will keep its referent alive after its last access. Serial GC only.", type = OptionType.Expert) //
-    public static final HostedOptionKey<Integer> SoftRefLRUPolicyMSPerMB = new HostedOptionKey<>(1000, SerialGCOptions::serialGCOnly);
+                    "for which a soft reference will keep its referent alive after its last access. Serial and parallel GC only.", type = OptionType.Expert) //
+    public static final HostedOptionKey<Integer> SoftRefLRUPolicyMSPerMB = new HostedOptionKey<>(1000, SerialGCOptions::serialOrParallelGCOnly);
 
-    @Option(help = "Print the shape of the heap before and after each collection, if +VerboseGC. Serial GC only.", type = OptionType.Debug)//
-    public static final RuntimeOptionKey<Boolean> PrintHeapShape = new RuntimeOptionKey<>(false, SerialGCOptions::serialGCOnly);
+    @Option(help = "Print the shape of the heap before and after each collection, if +VerboseGC. Serial and parallel GC only.", type = OptionType.Debug)//
+    public static final RuntimeOptionKey<Boolean> PrintHeapShape = new RuntimeOptionKey<>(false, SerialGCOptions::serialOrParallelGCOnly);
 
-    @Option(help = "Print summary GC information after application main method returns. Serial GC only.", type = OptionType.Debug)//
-    public static final RuntimeOptionKey<Boolean> PrintGCSummary = new RuntimeOptionKey<>(false, SerialGCOptions::serialGCOnly);
+    @Option(help = "Print summary GC information after application main method returns. Serial and parallel GC only.", type = OptionType.Debug)//
+    public static final RuntimeOptionKey<Boolean> PrintGCSummary = new RuntimeOptionKey<>(false, SerialGCOptions::serialOrParallelGCOnly);
 
-    @Option(help = "Print a time stamp at each collection, if +PrintGC or +VerboseGC. Serial GC only.", type = OptionType.Debug)//
-    public static final RuntimeOptionKey<Boolean> PrintGCTimeStamps = new RuntimeOptionKey<>(false, SerialGCOptions::serialGCOnly);
+    @Option(help = "Print a time stamp at each collection, if +PrintGC or +VerboseGC. Serial and parallel GC only.", type = OptionType.Debug)//
+    public static final RuntimeOptionKey<Boolean> PrintGCTimeStamps = new RuntimeOptionKey<>(false, SerialGCOptions::serialOrParallelGCOnly);
 
-    @Option(help = "Print the time for each of the phases of each collection, if +VerboseGC. Serial GC only.", type = OptionType.Debug)//
-    public static final RuntimeOptionKey<Boolean> PrintGCTimes = new RuntimeOptionKey<>(false, SerialGCOptions::serialGCOnly);
+    @Option(help = "Print the time for each of the phases of each collection, if +VerboseGC. Serial and parallel GC only.", type = OptionType.Debug)//
+    public static final RuntimeOptionKey<Boolean> PrintGCTimes = new RuntimeOptionKey<>(false, SerialGCOptions::serialOrParallelGCOnly);
 
-    @Option(help = "Instrument write barriers with counters. Serial GC only.", type = OptionType.Debug)//
-    public static final HostedOptionKey<Boolean> CountWriteBarriers = new HostedOptionKey<>(false, SerialGCOptions::serialGCOnly);
+    @Option(help = "Instrument write barriers with counters. Serial and parallel GC only.", type = OptionType.Debug)//
+    public static final HostedOptionKey<Boolean> CountWriteBarriers = new HostedOptionKey<>(false, SerialGCOptions::serialOrParallelGCOnly);
 
-    @Option(help = "Verify the remembered set if VerifyHeap is enabled. Serial GC only.", type = OptionType.Debug)//
-    public static final HostedOptionKey<Boolean> VerifyRememberedSet = new HostedOptionKey<>(true, SerialGCOptions::serialGCOnly);
+    @Option(help = "Verify the remembered set if VerifyHeap is enabled. Serial and parallel GC only.", type = OptionType.Debug)//
+    public static final HostedOptionKey<Boolean> VerifyRememberedSet = new HostedOptionKey<>(true, SerialGCOptions::serialOrParallelGCOnly);
 
-    @Option(help = "Verify all object references if VerifyHeap is enabled. Serial GC only.", type = OptionType.Debug)//
-    public static final HostedOptionKey<Boolean> VerifyReferences = new HostedOptionKey<>(true, SerialGCOptions::serialGCOnly);
+    @Option(help = "Verify all object references if VerifyHeap is enabled. Serial and parallel GC only.", type = OptionType.Debug)//
+    public static final HostedOptionKey<Boolean> VerifyReferences = new HostedOptionKey<>(true, SerialGCOptions::serialOrParallelGCOnly);
 
-    @Option(help = "Verify write barriers. Serial GC only.", type = OptionType.Debug)//
-    public static final HostedOptionKey<Boolean> VerifyWriteBarriers = new HostedOptionKey<>(false, SerialGCOptions::serialGCOnly);
+    @Option(help = "Verify write barriers. Serial and parallel GC only.", type = OptionType.Debug)//
+    public static final HostedOptionKey<Boolean> VerifyWriteBarriers = new HostedOptionKey<>(false, SerialGCOptions::serialOrParallelGCOnly);
 
-    @Option(help = "Trace heap chunks during collections, if +VerboseGC and +PrintHeapShape. Serial GC only.", type = OptionType.Debug) //
-    public static final RuntimeOptionKey<Boolean> TraceHeapChunks = new RuntimeOptionKey<>(false, SerialGCOptions::serialGCOnly);
+    @Option(help = "Trace heap chunks during collections, if +VerboseGC and +PrintHeapShape. Serial and parallel GC only.", type = OptionType.Debug) //
+    public static final RuntimeOptionKey<Boolean> TraceHeapChunks = new RuntimeOptionKey<>(false, SerialGCOptions::serialOrParallelGCOnly);
 
-    @Option(help = "Develop demographics of the object references visited. Serial GC only.", type = OptionType.Debug)//
-    public static final HostedOptionKey<Boolean> GreyToBlackObjRefDemographics = new HostedOptionKey<>(false, SerialGCOptions::serialGCOnly);
+    @Option(help = "Develop demographics of the object references visited. Serial and parallel GC only.", type = OptionType.Debug)//
+    public static final HostedOptionKey<Boolean> GreyToBlackObjRefDemographics = new HostedOptionKey<>(false, SerialGCOptions::serialOrParallelGCOnly);
 
     private SerialGCOptions() {
     }
 
-    private static void serialGCOnly(OptionKey<?> optionKey) {
-        if (!SubstrateOptions.UseSerialGC.getValue()) {
-            throw new InterruptImageBuilding("The option '" + optionKey.getName() + "' can only be used together with the serial garbage collector ('--gc=serial').");
+    private static void serialOrParallelGCOnly(OptionKey<?> optionKey) {
+        if (!SubstrateOptions.useSerialOrParallelGC()) {
+            throw new InterruptImageBuilding("The option '" + optionKey.getName() + "' can only be used together with the serial ('--gc=serial') or parallel garbage collector ('--gc=parallel').");
         }
     }
 }
diff --git a/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/Space.java b/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/Space.java
index 680bcff2c8a..fad7dd688ff 100644
--- a/graal/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/Space.java
+++ b/graal/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/Space.java
@@ -43,6 +43,7 @@ import com.oracle.svm.core.Uninterruptible;
 import com.oracle.svm.core.UnmanagedMemoryUtil;
 import com.oracle.svm.core.config.ConfigurationValues;
 import com.oracle.svm.core.genscavenge.GCImpl.ChunkReleaser;
+import com.oracle.svm.core.genscavenge.parallel.ParallelGC;
 import com.oracle.svm.core.genscavenge.remset.RememberedSet;
 import com.oracle.svm.core.heap.ObjectVisitor;
 import com.oracle.svm.core.hub.LayoutEncoding;
@@ -93,14 +94,18 @@ public final class Space {
         return name;
     }
 
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     public boolean isEmpty() {
-        return (getFirstAlignedHeapChunk().isNull() && getFirstUnalignedHeapChunk().isNull());
+        return firstAlignedHeapChunk.isNull() && firstUnalignedHeapChunk.isNull();
     }
 
     @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     void tearDown() {
-        HeapChunkProvider.freeAlignedChunkList(getFirstAlignedHeapChunk());
-        HeapChunkProvider.freeUnalignedChunkList(getFirstUnalignedHeapChunk());
+        HeapChunkProvider.freeAlignedChunkList(firstAlignedHeapChunk);
+        firstAlignedHeapChunk = WordFactory.nullPointer();
+
+        HeapChunkProvider.freeUnalignedChunkList(firstUnalignedHeapChunk);
+        firstUnalignedHeapChunk = WordFactory.nullPointer();
     }
 
     @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
@@ -108,10 +113,12 @@ public final class Space {
         return age == 0;
     }
 
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     public boolean isYoungSpace() {
         return age <= HeapParameters.getMaxSurvivorSpaces();
     }
 
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     boolean isSurvivorSpace() {
         return age > 0 && age <= HeapParameters.getMaxSurvivorSpaces();
     }
@@ -121,27 +128,42 @@ public final class Space {
         return age == (HeapParameters.getMaxSurvivorSpaces() + 1);
     }
 
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     int getAge() {
         return age;
     }
 
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     int getNextAgeForPromotion() {
         return age + 1;
     }
 
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     boolean isFromSpace() {
         return isFromSpace;
     }
 
+    @AlwaysInline("GC performance")
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
+    public void walkAllocChunk(AlignedHeapChunk.AlignedHeader allocChunk, Pointer start, GreyToBlackObjectVisitor visitor) {
+        assert allocChunk.isNonNull();
+        assert HeapChunk.getTopPointer(allocChunk).aboveThan(start);
+        HeapChunk.walkObjectsFromInline(allocChunk, start, visitor);
+        if (start.equal(ParallelGC.singleton().getAllocChunkScanPointer(age, false))) {
+            // Update top offset so that we don't scan the same objects again
+            ParallelGC.singleton().setAllocChunk(age, allocChunk);
+        }
+    }
+
     public boolean walkObjects(ObjectVisitor visitor) {
-        AlignedHeapChunk.AlignedHeader aChunk = getFirstAlignedHeapChunk();
+        AlignedHeapChunk.AlignedHeader aChunk = firstAlignedHeapChunk;
         while (aChunk.isNonNull()) {
             if (!AlignedHeapChunk.walkObjects(aChunk, visitor)) {
                 return false;
             }
             aChunk = HeapChunk.getNext(aChunk);
         }
-        UnalignedHeapChunk.UnalignedHeader uChunk = getFirstUnalignedHeapChunk();
+        UnalignedHeapChunk.UnalignedHeader uChunk = firstUnalignedHeapChunk;
         while (uChunk.isNonNull()) {
             if (!UnalignedHeapChunk.walkObjects(uChunk, visitor)) {
                 return false;
@@ -156,8 +178,8 @@ public final class Space {
         log.string(getName()).string(":").indent(true);
         accounting.report(log);
         if (traceHeapChunks) {
-            HeapChunkLogging.logChunks(log, getFirstAlignedHeapChunk());
-            HeapChunkLogging.logChunks(log, getFirstUnalignedHeapChunk());
+            HeapChunkLogging.logChunks(log, firstAlignedHeapChunk);
+            HeapChunkLogging.logChunks(log, firstUnalignedHeapChunk);
         }
         log.redent(false);
         return log;
@@ -167,20 +189,80 @@ public final class Space {
      * Allocate memory from an AlignedHeapChunk in this Space.
      */
     @AlwaysInline("GC performance")
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     private Pointer allocateMemory(UnsignedWord objectSize) {
-        Pointer result = WordFactory.nullPointer();
+        if (ParallelGC.isEnabled()) {
+            return allocateMemoryParallel(objectSize);
+        }
+        return allocateMemorySerial(objectSize);
+    }
+
+    @AlwaysInline("GC performance")
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
+    private Pointer allocateMemorySerial(UnsignedWord objectSize) {
+        assert !ParallelGC.isEnabled();
+
         /* Fast-path: try allocating in the last chunk. */
-        AlignedHeapChunk.AlignedHeader oldChunk = getLastAlignedHeapChunk();
+        AlignedHeapChunk.AlignedHeader oldChunk = lastAlignedHeapChunk;
         if (oldChunk.isNonNull()) {
-            result = AlignedHeapChunk.allocateMemory(oldChunk, objectSize);
-        }
-        if (result.isNonNull()) {
-            return result;
+            Pointer result = AlignedHeapChunk.allocateMemory(oldChunk, objectSize);
+            if (result.isNonNull()) {
+                return result;
+            }
         }
         /* Slow-path: try allocating a new chunk for the requested memory. */
         return allocateInNewChunk(objectSize);
     }
 
+    @AlwaysInline("GC performance")
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
+    private Pointer allocateMemoryParallel(UnsignedWord objectSize) {
+        /* Fast-path: try allocating in the thread local allocation chunk. */
+        Pointer oldChunkPtr = ParallelGC.singleton().getAllocChunkScanPointer(age, false);
+        if (oldChunkPtr.isNonNull()) {
+            AlignedHeapChunk.AlignedHeader oldChunk = AlignedHeapChunk.getEnclosingChunkFromObjectPointer(oldChunkPtr);
+            assert oldChunk.isNonNull();
+            Pointer result = AlignedHeapChunk.allocateMemory(oldChunk, objectSize);
+            if (result.isNonNull()) {
+                return result;
+            }
+        }
+        /* Slow-path: try allocating a new chunk for the requested memory. */
+        return allocateInNewChunkParallel(oldChunkPtr, objectSize);
+    }
+
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
+    private Pointer allocateInNewChunkParallel(Pointer oldChunkPtr, UnsignedWord objectSize) {
+        AlignedHeapChunk.AlignedHeader newChunk;
+        ParallelGC.singleton().getMutex().lockNoTransitionUnspecifiedOwner();
+        try {
+            if (oldChunkPtr.isNonNull()) {
+                ParallelGC.singleton().pushAllocChunk(oldChunkPtr);
+            }
+            newChunk = requestAlignedHeapChunk();
+        } finally {
+            ParallelGC.singleton().getMutex().unlockNoTransitionUnspecifiedOwner();
+        }
+
+        ParallelGC.singleton().setAllocChunk(age, newChunk);
+        if (newChunk.isNonNull()) {
+            return AlignedHeapChunk.allocateMemory(newChunk, objectSize);
+        }
+        return WordFactory.nullPointer();
+    }
+
+    /** Retract the latest allocation. */
+    @AlwaysInline("GC performance")
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
+    private void retractAllocationParallel(UnsignedWord objectSize) {
+        assert ParallelGC.isEnabled() && ParallelGC.singleton().isInParallelPhase();
+        Pointer allocChunkPtr = ParallelGC.singleton().getAllocChunkScanPointer(age, false);
+        AlignedHeapChunk.AlignedHeader chunk = AlignedHeapChunk.getEnclosingChunkFromObjectPointer(allocChunkPtr);
+        assert chunk.isNonNull();
+        AlignedHeapChunk.retractAllocation(chunk, objectSize);
+    }
+
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     private Pointer allocateInNewChunk(UnsignedWord objectSize) {
         AlignedHeapChunk.AlignedHeader newChunk = requestAlignedHeapChunk();
         if (newChunk.isNonNull()) {
@@ -189,6 +271,7 @@ public final class Space {
         return WordFactory.nullPointer();
     }
 
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     public void releaseChunks(ChunkReleaser chunkReleaser) {
         chunkReleaser.add(firstAlignedHeapChunk);
         chunkReleaser.add(firstUnalignedHeapChunk);
@@ -200,121 +283,113 @@ public final class Space {
         accounting.reset();
     }
 
-    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
-    void appendAlignedHeapChunk(AlignedHeapChunk.AlignedHeader aChunk) {
-        /*
-         * This method is used from {@link PosixJavaThreads#detachThread(VMThread)}, so it can not
-         * guarantee that it is inside a VMOperation, only that there is some mutual exclusion.
-         */
-        if (SubstrateOptions.MultiThreaded.getValue()) {
-            VMThreads.guaranteeOwnsThreadMutex("Trying to append an aligned heap chunk but no mutual exclusion.");
+    @Uninterruptible(reason = "Must not interact with garbage collections.")
+    void appendAlignedHeapChunk(AlignedHeapChunk.AlignedHeader aChunk, Space originalSpace) {
+        assert verifyMutualExclusionForAppendChunk() : "Trying to append an aligned heap chunk but no mutual exclusion.";
+        assert HeapChunk.getSpace(aChunk) == originalSpace;
+        assert this != originalSpace;
+
+        if (originalSpace != null) {
+            originalSpace.extractAlignedHeapChunk(aChunk);
         }
-        appendAlignedHeapChunkUninterruptibly(aChunk);
-        accounting.noteAlignedHeapChunk();
-    }
 
-    @Uninterruptible(reason = "Must not interact with garbage collections.")
-    private void appendAlignedHeapChunkUninterruptibly(AlignedHeapChunk.AlignedHeader aChunk) {
-        AlignedHeapChunk.AlignedHeader oldLast = getLastAlignedHeapChunk();
         HeapChunk.setSpace(aChunk, this);
+        AlignedHeapChunk.AlignedHeader oldLast = lastAlignedHeapChunk;
         HeapChunk.setPrevious(aChunk, oldLast);
         HeapChunk.setNext(aChunk, WordFactory.nullPointer());
         if (oldLast.isNonNull()) {
             HeapChunk.setNext(oldLast, aChunk);
         }
-        setLastAlignedHeapChunk(aChunk);
-        if (getFirstAlignedHeapChunk().isNull()) {
-            setFirstAlignedHeapChunk(aChunk);
+        lastAlignedHeapChunk = aChunk;
+        if (firstAlignedHeapChunk.isNull()) {
+            firstAlignedHeapChunk = aChunk;
         }
+        accounting.noteAlignedHeapChunk();
     }
 
-    void extractAlignedHeapChunk(AlignedHeapChunk.AlignedHeader aChunk) {
-        assert VMOperation.isGCInProgress() : "Should only be called by the collector.";
-        extractAlignedHeapChunkUninterruptibly(aChunk);
-        accounting.unnoteAlignedHeapChunk();
+    @Uninterruptible(reason = "Must not interact with garbage collections.")
+    void appendUnalignedHeapChunk(UnalignedHeapChunk.UnalignedHeader uChunk, Space originalSpace) {
+        assert verifyMutualExclusionForAppendChunk() : "Trying to append an aligned heap chunk but no mutual exclusion.";
+        assert uChunk.getSpace() == originalSpace;
+        assert this != originalSpace;
+
+        if (originalSpace != null) {
+            originalSpace.extractUnalignedHeapChunk(uChunk);
+        }
+
+        if (uChunk.getSpace() == this) {
+            return;
+        }
+        uChunk.setSpace(this);
+
+        UnalignedHeapChunk.UnalignedHeader oldLast = lastUnalignedHeapChunk;
+        HeapChunk.setPrevious(uChunk, oldLast);
+        HeapChunk.setNext(uChunk, WordFactory.nullPointer());
+        if (oldLast.isNonNull()) {
+            HeapChunk.setNext(oldLast, uChunk);
+        }
+        lastUnalignedHeapChunk = uChunk;
+        if (firstUnalignedHeapChunk.isNull()) {
+            firstUnalignedHeapChunk = uChunk;
+        }
+        accounting.noteUnalignedHeapChunk(uChunk);
     }
 
     @Uninterruptible(reason = "Must not interact with garbage collections.")
-    private void extractAlignedHeapChunkUninterruptibly(AlignedHeapChunk.AlignedHeader aChunk) {
+    private void extractAlignedHeapChunk(AlignedHeapChunk.AlignedHeader aChunk) {
+        assert VMOperation.isGCInProgress();
+
         AlignedHeapChunk.AlignedHeader chunkNext = HeapChunk.getNext(aChunk);
         AlignedHeapChunk.AlignedHeader chunkPrev = HeapChunk.getPrevious(aChunk);
         if (chunkPrev.isNonNull()) {
             HeapChunk.setNext(chunkPrev, chunkNext);
         } else {
-            setFirstAlignedHeapChunk(chunkNext);
+            firstAlignedHeapChunk = chunkNext;
         }
         if (chunkNext.isNonNull()) {
             HeapChunk.setPrevious(chunkNext, chunkPrev);
         } else {
-            setLastAlignedHeapChunk(chunkPrev);
+            lastAlignedHeapChunk = chunkPrev;
         }
         HeapChunk.setNext(aChunk, WordFactory.nullPointer());
         HeapChunk.setPrevious(aChunk, WordFactory.nullPointer());
         HeapChunk.setSpace(aChunk, null);
-    }
-
-    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
-    void appendUnalignedHeapChunk(UnalignedHeapChunk.UnalignedHeader uChunk) {
-        /*
-         * This method is used from {@link PosixJavaThreads#detachThread(VMThread)}, so it can not
-         * guarantee that it is inside a VMOperation, only that there is some mutual exclusion.
-         */
-        if (SubstrateOptions.MultiThreaded.getValue()) {
-            VMThreads.guaranteeOwnsThreadMutex("Trying to append an unaligned chunk but no mutual exclusion.");
-        }
-        appendUnalignedHeapChunkUninterruptibly(uChunk);
-        accounting.noteUnalignedHeapChunk(uChunk);
+        accounting.unnoteAlignedHeapChunk();
     }
 
     @Uninterruptible(reason = "Must not interact with garbage collections.")
-    private void appendUnalignedHeapChunkUninterruptibly(UnalignedHeapChunk.UnalignedHeader uChunk) {
-        UnalignedHeapChunk.UnalignedHeader oldLast = getLastUnalignedHeapChunk();
-        HeapChunk.setSpace(uChunk, this);
-        HeapChunk.setPrevious(uChunk, oldLast);
-        HeapChunk.setNext(uChunk, WordFactory.nullPointer());
-        if (oldLast.isNonNull()) {
-            HeapChunk.setNext(oldLast, uChunk);
-        }
-        setLastUnalignedHeapChunk(uChunk);
-        if (getFirstUnalignedHeapChunk().isNull()) {
-            setFirstUnalignedHeapChunk(uChunk);
-        }
-    }
-
-    void extractUnalignedHeapChunk(UnalignedHeapChunk.UnalignedHeader uChunk) {
-        assert VMOperation.isGCInProgress() : "Trying to extract an unaligned chunk but not in a VMOperation.";
-        extractUnalignedHeapChunkUninterruptibly(uChunk);
-        accounting.unnoteUnalignedHeapChunk(uChunk);
-    }
+    private void extractUnalignedHeapChunk(UnalignedHeapChunk.UnalignedHeader uChunk) {
+        assert VMOperation.isGCInProgress();
 
-    @Uninterruptible(reason = "Must not interact with garbage collections.")
-    private void extractUnalignedHeapChunkUninterruptibly(UnalignedHeapChunk.UnalignedHeader uChunk) {
         UnalignedHeapChunk.UnalignedHeader chunkNext = HeapChunk.getNext(uChunk);
         UnalignedHeapChunk.UnalignedHeader chunkPrev = HeapChunk.getPrevious(uChunk);
         if (chunkPrev.isNonNull()) {
             HeapChunk.setNext(chunkPrev, chunkNext);
         } else {
-            setFirstUnalignedHeapChunk(chunkNext);
+            firstUnalignedHeapChunk = chunkNext;
         }
         if (chunkNext.isNonNull()) {
             HeapChunk.setPrevious(chunkNext, chunkPrev);
         } else {
-            setLastUnalignedHeapChunk(chunkPrev);
+            lastUnalignedHeapChunk = chunkPrev;
         }
         /* Reset the fields that the result chunk keeps for Space. */
         HeapChunk.setNext(uChunk, WordFactory.nullPointer());
         HeapChunk.setPrevious(uChunk, WordFactory.nullPointer());
         HeapChunk.setSpace(uChunk, null);
+        accounting.unnoteUnalignedHeapChunk(uChunk);
     }
 
     @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
-    public AlignedHeapChunk.AlignedHeader getFirstAlignedHeapChunk() {
-        return firstAlignedHeapChunk;
+    private static boolean verifyMutualExclusionForAppendChunk() {
+        return !SubstrateOptions.MultiThreaded.getValue() ||
+                        VMThreads.ownsThreadMutex(true) ||
+                        ParallelGC.isEnabled() && VMOperation.isGCInProgress() && ParallelGC.singleton().isInParallelPhase() && ParallelGC.singleton().getMutex().isOwner(true);
     }
 
     @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
-    private void setFirstAlignedHeapChunk(AlignedHeapChunk.AlignedHeader chunk) {
-        firstAlignedHeapChunk = chunk;
+    public AlignedHeapChunk.AlignedHeader getFirstAlignedHeapChunk() {
+        return firstAlignedHeapChunk;
     }
 
     @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
@@ -322,46 +397,32 @@ public final class Space {
         return lastAlignedHeapChunk;
     }
 
-    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
-    private void setLastAlignedHeapChunk(AlignedHeapChunk.AlignedHeader chunk) {
-        lastAlignedHeapChunk = chunk;
-    }
-
     @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     public UnalignedHeapChunk.UnalignedHeader getFirstUnalignedHeapChunk() {
         return firstUnalignedHeapChunk;
     }
 
-    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
-    private void setFirstUnalignedHeapChunk(UnalignedHeapChunk.UnalignedHeader chunk) {
-        this.firstUnalignedHeapChunk = chunk;
-    }
-
     @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     UnalignedHeapChunk.UnalignedHeader getLastUnalignedHeapChunk() {
         return lastUnalignedHeapChunk;
     }
 
-    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
-    private void setLastUnalignedHeapChunk(UnalignedHeapChunk.UnalignedHeader chunk) {
-        lastUnalignedHeapChunk = chunk;
-    }
-
     /** Promote an aligned Object to this Space. */
     @AlwaysInline("GC performance")
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     Object promoteAlignedObject(Object original, Space originalSpace) {
         assert ObjectHeaderImpl.isAlignedObject(original);
         assert this != originalSpace && originalSpace.isFromSpace();
 
-        Object copy = copyAlignedObject(original);
-        if (copy != null) {
-            ObjectHeaderImpl.getObjectHeaderImpl().installForwardingPointer(original, copy);
+        if (ParallelGC.isEnabled() && ParallelGC.singleton().isInParallelPhase()) {
+            return copyAlignedObjectParallel(original);
         }
-        return copy;
+        return copyAlignedObjectSerial(original);
     }
 
     @AlwaysInline("GC performance")
-    private Object copyAlignedObject(Object originalObj) {
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
+    private Object copyAlignedObjectSerial(Object originalObj) {
         assert VMOperation.isGCInProgress();
         assert ObjectHeaderImpl.isAlignedObject(originalObj);
 
@@ -386,17 +447,104 @@ public final class Space {
          * references. That's okay, because all references in the copy are visited and overwritten
          * later on anyways (the card table is also updated at that point if necessary).
          */
-        Pointer originalMemory = Word.objectToUntrackedPointer(originalObj);
+        Word originalMemory = Word.objectToUntrackedPointer(originalObj);
         UnmanagedMemoryUtil.copyLongsForward(originalMemory, copyMemory, originalSize);
 
         Object copy = copyMemory.toObject();
         if (probability(SLOW_PATH_PROBABILITY, addIdentityHashField)) {
             // Must do first: ensures correct object size below and in other places
-            int value = IdentityHashCodeSupport.computeHashCodeFromAddress(originalObj);
+            AlignedHeapChunk.AlignedHeader originalChunk = AlignedHeapChunk.getEnclosingChunkFromObjectPointer(originalMemory);
+            int value = IdentityHashCodeSupport.computeHashCodeFromAddress(originalMemory, HeapChunk.getIdentityHashSalt(originalChunk));
             int offset = LayoutEncoding.getOptionalIdentityHashOffset(copy);
             ObjectAccess.writeInt(copy, offset, value, IdentityHashCodeSupport.IDENTITY_HASHCODE_LOCATION);
             ObjectHeaderImpl.getObjectHeaderImpl().setIdentityHashInField(copy);
         }
+        if (isOldSpace()) {
+            // If the object was promoted to the old gen, we need to take care of the remembered
+            // set bit and the first object table (even when promoting from old to old).
+            AlignedHeapChunk.AlignedHeader copyChunk = AlignedHeapChunk.getEnclosingChunk(copy);
+            RememberedSet.get().enableRememberedSetForObject(copyChunk, copy);
+        }
+
+        ObjectHeaderImpl.getObjectHeaderImpl().installForwardingPointer(originalObj, copy);
+        return copy;
+    }
+
+    @AlwaysInline("GC performance")
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
+    private Object copyAlignedObjectParallel(Object original) {
+        assert VMOperation.isGCInProgress();
+
+        /*
+         * The GC worker thread doesn't own the object yet, so the 8 bytes starting at the hub
+         * offset can be changed at any time (if another GC worker thread forwards the object). Note
+         * that those bytes may also include data such as the array length.
+         *
+         * So, we read the 8 bytes at the hub offset once and then extract all necessary data from
+         * those bytes. This is necessary to avoid races.
+         */
+        Word originalMemory = Word.objectToUntrackedPointer(original);
+        int hubOffset = ObjectHeaderImpl.getHubOffset();
+        long eightHeaderBytes = originalMemory.readLong(hubOffset);
+        Word originalHeader = ObjectHeaderImpl.hasShift() ? WordFactory.unsigned(eightHeaderBytes & 0xFFFFFFFFL) : WordFactory.unsigned(eightHeaderBytes);
+        assert ObjectHeaderImpl.isAlignedHeader(originalHeader);
+
+        ObjectHeaderImpl ohi = ObjectHeaderImpl.getObjectHeaderImpl();
+        if (ObjectHeaderImpl.isForwardedHeader(originalHeader)) {
+            return ohi.getForwardedObject(originalMemory, originalHeader);
+        }
+
+        /*
+         * We need the forwarding pointer to point somewhere, so we speculatively allocate memory
+         * here. If another thread copies the object first, we retract the allocation later.
+         */
+        UnsignedWord originalSize = LayoutEncoding.getSizeFromHeader(original, originalHeader, eightHeaderBytes, false);
+        UnsignedWord copySize = originalSize;
+        boolean addIdentityHashField = false;
+        if (!ConfigurationValues.getObjectLayout().hasFixedIdentityHashField()) {
+            if (probability(SLOW_PATH_PROBABILITY, ObjectHeaderImpl.hasIdentityHashFromAddressInline(originalHeader))) {
+                addIdentityHashField = true;
+                copySize = LayoutEncoding.getSizeFromHeader(original, originalHeader, eightHeaderBytes, true);
+            }
+        }
+
+        assert copySize.aboveThan(0);
+        Pointer copyMemory = allocateMemoryParallel(copySize);
+        if (probability(VERY_SLOW_PATH_PROBABILITY, copyMemory.isNull())) {
+            return null;
+        }
+
+        /*
+         * It's important that we set the RS bit before everything else because
+         * YoungGeneration.contains() checks it.
+         */
+        long copyHeaderBytes = isOldSpace() ? ObjectHeaderImpl.setRememberedSetBit(eightHeaderBytes) : eightHeaderBytes;
+        copyMemory.writeLong(hubOffset, copyHeaderBytes);
+
+        /* Install forwarding pointer into the original header. */
+        Object copy = copyMemory.toObject();
+        Object forward = ohi.installForwardingPointerParallel(original, eightHeaderBytes, copy);
+        if (forward != copy) {
+            /* We lost the race. Retract speculatively allocated memory. */
+            retractAllocationParallel(copySize);
+            return forward;
+        }
+
+        /* We have won the race. Copy the rest of the object. */
+        if (hubOffset > 0) {
+            UnmanagedMemoryUtil.copyLongsForward(originalMemory, copyMemory, WordFactory.unsigned(hubOffset));
+        }
+        int offset = hubOffset + Long.BYTES;
+        UnmanagedMemoryUtil.copyLongsForward(originalMemory.add(offset), copyMemory.add(offset), originalSize.subtract(offset));
+
+        if (probability(SLOW_PATH_PROBABILITY, addIdentityHashField)) {
+            AlignedHeapChunk.AlignedHeader originalChunk = AlignedHeapChunk.getEnclosingChunkFromObjectPointer(originalMemory);
+            int value = IdentityHashCodeSupport.computeHashCodeFromAddress(originalMemory, HeapChunk.getIdentityHashSalt(originalChunk));
+            offset = LayoutEncoding.getOptionalIdentityHashOffset(copy);
+            ObjectAccess.writeInt(copy, offset, value, IdentityHashCodeSupport.IDENTITY_HASHCODE_LOCATION);
+            ObjectHeaderImpl.getObjectHeaderImpl().setIdentityHashInField(copy);
+        }
+
         if (isOldSpace()) {
             // If the object was promoted to the old gen, we need to take care of the remembered
             // set bit and the first object table (even when promoting from old to old).
@@ -407,12 +555,15 @@ public final class Space {
     }
 
     /** Promote an AlignedHeapChunk by moving it to this space. */
-    void promoteAlignedHeapChunk(AlignedHeapChunk.AlignedHeader chunk, Space originalSpace) {
-        assert this != originalSpace && originalSpace.isFromSpace();
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
+    void promoteAlignedHeapChunk(AlignedHeapChunk.AlignedHeader chunk) {
+        assert !(ParallelGC.isEnabled() && ParallelGC.singleton().isInParallelPhase());
 
-        originalSpace.extractAlignedHeapChunk(chunk);
-        appendAlignedHeapChunk(chunk);
+        Space originalSpace = HeapChunk.getSpace(chunk);
+        assert originalSpace.isFromSpace();
+        assert !this.isFromSpace();
 
+        appendAlignedHeapChunk(chunk, originalSpace);
         if (this.isOldSpace()) {
             if (originalSpace.isYoungSpace()) {
                 RememberedSet.get().enableRememberedSetForChunk(chunk);
@@ -421,15 +572,51 @@ public final class Space {
                 RememberedSet.get().clearRememberedSet(chunk);
             }
         }
+
+        if (ParallelGC.isEnabled()) {
+            ParallelGC.singleton().push(chunk, ParallelGC.SCAN_GREY_OBJECTS);
+        }
     }
 
     /** Promote an UnalignedHeapChunk by moving it to this Space. */
-    void promoteUnalignedHeapChunk(UnalignedHeapChunk.UnalignedHeader chunk, Space originalSpace) {
-        assert this != originalSpace && originalSpace.isFromSpace();
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
+    void promoteUnalignedHeapChunk(UnalignedHeapChunk.UnalignedHeader chunk) {
+        if (ParallelGC.isEnabled() && ParallelGC.singleton().isInParallelPhase()) {
+            promoteUnalignedHeapChunkParallel(chunk);
+        } else {
+            promoteUnalignedHeapChunkSerial(chunk);
+        }
+    }
 
-        originalSpace.extractUnalignedHeapChunk(chunk);
-        appendUnalignedHeapChunk(chunk);
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
+    private void promoteUnalignedHeapChunkSerial(UnalignedHeapChunk.UnalignedHeader chunk) {
+        Space originalSpace = HeapChunk.getSpace(chunk);
+        promoteUnalignedHeapChunk0(chunk, originalSpace);
 
+        if (ParallelGC.isEnabled()) {
+            ParallelGC.singleton().push(chunk, ParallelGC.SCAN_GREY_OBJECTS);
+        }
+    }
+
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
+    private void promoteUnalignedHeapChunkParallel(UnalignedHeapChunk.UnalignedHeader chunk) {
+        ParallelGC.singleton().getMutex().lockNoTransitionUnspecifiedOwner();
+        try {
+            Space originalSpace = HeapChunk.getSpace(chunk);
+            if (!originalSpace.isFromSpace()) {
+                /* The chunk was already promoted in the meanwhile. */
+                return;
+            }
+            promoteUnalignedHeapChunk0(chunk, originalSpace);
+            ParallelGC.singleton().push(chunk, ParallelGC.SCAN_GREY_OBJECTS);
+        } finally {
+            ParallelGC.singleton().getMutex().unlockNoTransitionUnspecifiedOwner();
+        }
+    }
+
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
+    private void promoteUnalignedHeapChunk0(UnalignedHeapChunk.UnalignedHeader chunk, Space originalSpace) {
+        assert originalSpace.isFromSpace();
         if (this.isOldSpace()) {
             if (originalSpace.isYoungSpace()) {
                 RememberedSet.get().enableRememberedSetForChunk(chunk);
@@ -438,8 +625,10 @@ public final class Space {
                 RememberedSet.get().clearRememberedSet(chunk);
             }
         }
+        appendUnalignedHeapChunk(chunk, originalSpace);
     }
 
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     private AlignedHeapChunk.AlignedHeader requestAlignedHeapChunk() {
         AlignedHeapChunk.AlignedHeader chunk;
         if (isYoungSpace()) {
@@ -449,11 +638,12 @@ public final class Space {
             chunk = HeapImpl.getHeapImpl().getOldGeneration().requestAlignedChunk();
         }
         if (chunk.isNonNull()) {
-            appendAlignedHeapChunk(chunk);
+            appendAlignedHeapChunk(chunk, null);
         }
         return chunk;
     }
 
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     void absorb(Space src) {
         /*
          * Absorb the chunks of a source into this Space. I cannot just copy the lists, because each
@@ -462,27 +652,25 @@ public final class Space {
         AlignedHeapChunk.AlignedHeader aChunk = src.getFirstAlignedHeapChunk();
         while (aChunk.isNonNull()) {
             AlignedHeapChunk.AlignedHeader next = HeapChunk.getNext(aChunk);
-            src.extractAlignedHeapChunk(aChunk);
-            appendAlignedHeapChunk(aChunk);
+            appendAlignedHeapChunk(aChunk, src);
             aChunk = next;
         }
         UnalignedHeapChunk.UnalignedHeader uChunk = src.getFirstUnalignedHeapChunk();
         while (uChunk.isNonNull()) {
             UnalignedHeapChunk.UnalignedHeader next = HeapChunk.getNext(uChunk);
-            src.extractUnalignedHeapChunk(uChunk);
-            appendUnalignedHeapChunk(uChunk);
+            appendUnalignedHeapChunk(uChunk, src);
             uChunk = next;
         }
     }
 
     boolean walkHeapChunks(MemoryWalker.Visitor visitor) {
         boolean continueVisiting = true;
-        AlignedHeapChunk.AlignedHeader aChunk = getFirstAlignedHeapChunk();
+        AlignedHeapChunk.AlignedHeader aChunk = firstAlignedHeapChunk;
         while (continueVisiting && aChunk.isNonNull()) {
             continueVisiting = visitor.visitHeapChunk(aChunk, AlignedHeapChunk.getMemoryWalkerAccess());
             aChunk = HeapChunk.getNext(aChunk);
         }
-        UnalignedHeapChunk.UnalignedHeader uChunk = getFirstUnalignedHeapChunk();
+        UnalignedHeapChunk.UnalignedHeader uChunk = firstUnalignedHeapChunk;
         while (continueVisiting && uChunk.isNonNull()) {
             continueVisiting = visitor.visitHeapChunk(uChunk, UnalignedHeapChunk.getMemoryWalkerAccess());
             uChunk = HeapChunk.getNext(uChunk);
@@ -512,7 +700,7 @@ public final class Space {
 
     private UnsignedWord computeAlignedObjectBytes() {
         UnsignedWord result = WordFactory.zero();
-        AlignedHeapChunk.AlignedHeader aChunk = getFirstAlignedHeapChunk();
+        AlignedHeapChunk.AlignedHeader aChunk = firstAlignedHeapChunk;
         while (aChunk.isNonNull()) {
             UnsignedWord allocatedBytes = HeapChunk.getTopOffset(aChunk).subtract(AlignedHeapChunk.getObjectsStartOffset());
             result = result.add(allocatedBytes);
@@ -523,7 +711,7 @@ public final class Space {
 
     private UnsignedWord computeUnalignedObjectBytes() {
         UnsignedWord result = WordFactory.zero();
-        UnalignedHeapChunk.UnalignedHeader uChunk = getFirstUnalignedHeapChunk();
+        UnalignedHeapChunk.UnalignedHeader uChunk = firstUnalignedHeapChunk;
         while (uChunk.isNonNull()) {
             UnsignedWord allocatedBytes = HeapChunk.getTopOffset(uChunk).subtract(UnalignedHeapChunk.getObjectStartOffset());
             result = result.add(allocatedBytes);
diff --git a/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/ThreadLocalAllocation.java b/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/ThreadLocalAllocation.java
index e04769be8a9..9e09195a405 100644
--- a/graal/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/ThreadLocalAllocation.java
+++ b/graal/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/ThreadLocalAllocation.java
@@ -474,14 +474,14 @@ public final class ThreadLocalAllocation {
         while (alignedChunk.isNonNull()) {
             AlignedHeader next = HeapChunk.getNext(alignedChunk);
             HeapChunk.setNext(alignedChunk, WordFactory.nullPointer());
-            eden.appendAlignedHeapChunk(alignedChunk);
+            eden.appendAlignedHeapChunk(alignedChunk, null);
             alignedChunk = next;
         }
 
         while (unalignedChunk.isNonNull()) {
             UnalignedHeader next = HeapChunk.getNext(unalignedChunk);
             HeapChunk.setNext(unalignedChunk, WordFactory.nullPointer());
-            eden.appendUnalignedHeapChunk(unalignedChunk);
+            eden.appendUnalignedHeapChunk(unalignedChunk, null);
             unalignedChunk = next;
         }
     }
diff --git a/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/Timers.java b/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/Timers.java
index b86261133cc..a62552c9231 100644
--- a/graal/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/Timers.java
+++ b/graal/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/Timers.java
@@ -24,6 +24,7 @@
  */
 package com.oracle.svm.core.genscavenge;
 
+import com.oracle.svm.core.Uninterruptible;
 import com.oracle.svm.core.log.Log;
 
 /**
@@ -46,10 +47,12 @@ final class Timer implements AutoCloseable {
         return name;
     }
 
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     public Timer open() {
         return openAt(System.nanoTime());
     }
 
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     Timer openAt(long nanoTime) {
         openNanos = nanoTime;
         wasOpened = true;
@@ -59,10 +62,12 @@ final class Timer implements AutoCloseable {
     }
 
     @Override
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     public void close() {
         closeAt(System.nanoTime());
     }
 
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     void closeAt(long nanoTime) {
         closeNanos = nanoTime;
         wasClosed = true;
@@ -77,6 +82,7 @@ final class Timer implements AutoCloseable {
         collectedNanos = 0L;
     }
 
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     public long getOpenedTime() {
         if (!wasOpened) {
             /* If a timer was not opened, pretend it was opened at the start of the VM. */
diff --git a/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/UnalignedHeapChunk.java b/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/UnalignedHeapChunk.java
index 92d350a0549..eaaf7d4e58b 100644
--- a/graal/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/UnalignedHeapChunk.java
+++ b/graal/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/UnalignedHeapChunk.java
@@ -141,6 +141,7 @@ public final class UnalignedHeapChunk {
     }
 
     @AlwaysInline("GC performance")
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     public static boolean walkObjectsInline(UnalignedHeader that, ObjectVisitor visitor) {
         return HeapChunk.walkObjectsFromInline(that, getObjectStart(that), visitor);
     }
@@ -171,10 +172,5 @@ public final class UnalignedHeapChunk {
         public boolean isAligned(UnalignedHeapChunk.UnalignedHeader heapChunk) {
             return false;
         }
-
-        @Override
-        public UnsignedWord getAllocationStart(UnalignedHeapChunk.UnalignedHeader heapChunk) {
-            return getObjectStart(heapChunk);
-        }
     }
 }
diff --git a/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/UseSerialOrEpsilonGC.java b/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/UseSerialOrEpsilonGC.java
index 245874b4f0e..48be7c373ed 100644
--- a/graal/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/UseSerialOrEpsilonGC.java
+++ b/graal/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/UseSerialOrEpsilonGC.java
@@ -32,9 +32,10 @@ import org.graalvm.nativeimage.Platforms;
 import com.oracle.svm.core.SubstrateOptions;
 
 @Platforms(Platform.HOSTED_ONLY.class)
+// TODO (chaeubl): rename
 public class UseSerialOrEpsilonGC implements BooleanSupplier {
     @Override
     public boolean getAsBoolean() {
-        return SubstrateOptions.UseSerialGC.getValue() || SubstrateOptions.UseEpsilonGC.getValue();
+        return SubstrateOptions.useSerialOrParallelOrEpsilonGC();
     }
 }
diff --git a/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/YoungGeneration.java b/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/YoungGeneration.java
index f25fbcf3fcd..26722fb4c84 100644
--- a/graal/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/YoungGeneration.java
+++ b/graal/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/YoungGeneration.java
@@ -131,6 +131,7 @@ public final class YoungGeneration extends Generation {
         return survivorFromSpaces[index];
     }
 
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     private GreyObjectsWalker getSurvivorGreyObjectsWalker(int index) {
         return survivorGreyObjectsWalkers[index];
     }
@@ -163,6 +164,7 @@ public final class YoungGeneration extends Generation {
         return false;
     }
 
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     void prepareForPromotion() {
         for (int i = 0; i < maxSurvivorSpaces; i++) {
             assert getSurvivorToSpaceAt(i).isEmpty() : "SurvivorToSpace should be empty.";
@@ -170,8 +172,8 @@ public final class YoungGeneration extends Generation {
         }
     }
 
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     boolean scanGreyObjects() {
-        Log trace = Log.noopLog().string("[YoungGeneration.scanGreyObjects:");
         boolean needScan = false;
         for (int i = 0; i < maxSurvivorSpaces; i++) {
             if (getSurvivorGreyObjectsWalker(i).haveGreyObjects()) {
@@ -183,10 +185,8 @@ public final class YoungGeneration extends Generation {
             return false;
         }
         for (int i = 0; i < maxSurvivorSpaces; i++) {
-            trace.string("[Scanning survivor-").signed(i).string("]").newline();
             getSurvivorGreyObjectsWalker(i).walkGreyObjects();
         }
-        trace.string("]").newline();
         return true;
     }
 
@@ -237,6 +237,7 @@ public final class YoungGeneration extends Generation {
     }
 
     @AlwaysInline("GC performance")
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     @SuppressWarnings("static-method")
     public boolean contains(Object object) {
         if (!HeapImpl.usesImageHeapCardMarking()) {
@@ -250,10 +251,10 @@ public final class YoungGeneration extends Generation {
     }
 
     @AlwaysInline("GC performance")
-    @Override
-    protected Object promoteAlignedObject(Object original, AlignedHeapChunk.AlignedHeader originalChunk, Space originalSpace) {
-        assert originalSpace.isFromSpace();
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
+    Object promoteAlignedObject(Object original, Space originalSpace) {
         assert ObjectHeaderImpl.isAlignedObject(original);
+        assert originalSpace.isFromSpace();
         assert originalSpace.getAge() < maxSurvivorSpaces;
 
         // The object might fit in an existing chunk in the survivor space. If it doesn't, we get
@@ -265,8 +266,8 @@ public final class YoungGeneration extends Generation {
     }
 
     @AlwaysInline("GC performance")
-    @Override
-    protected Object promoteUnalignedObject(Object original, UnalignedHeapChunk.UnalignedHeader originalChunk, Space originalSpace) {
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
+    Object promoteUnalignedObject(Object original, UnalignedHeapChunk.UnalignedHeader originalChunk, Space originalSpace) {
         assert originalSpace.isFromSpace();
         assert originalSpace.getAge() < maxSurvivorSpaces;
         if (!unalignedChunkFitsInSurvivors(originalChunk)) {
@@ -275,12 +276,12 @@ public final class YoungGeneration extends Generation {
 
         int age = originalSpace.getNextAgeForPromotion();
         Space toSpace = getSurvivorToSpaceAt(age - 1);
-        toSpace.promoteUnalignedHeapChunk(originalChunk, originalSpace);
+        toSpace.promoteUnalignedHeapChunk(originalChunk);
         return original;
     }
 
-    @Override
-    protected boolean promoteChunk(HeapChunk.Header<?> originalChunk, boolean isAligned, Space originalSpace) {
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
+    boolean promoteChunk(HeapChunk.Header<?> originalChunk, boolean isAligned, Space originalSpace) {
         assert originalSpace.isFromSpace();
         assert originalSpace.getAge() < maxSurvivorSpaces;
         if (!fitsInSurvivors(originalChunk, isAligned)) {
@@ -290,13 +291,14 @@ public final class YoungGeneration extends Generation {
         int age = originalSpace.getNextAgeForPromotion();
         Space toSpace = getSurvivorToSpaceAt(age - 1);
         if (isAligned) {
-            toSpace.promoteAlignedHeapChunk((AlignedHeapChunk.AlignedHeader) originalChunk, originalSpace);
+            toSpace.promoteAlignedHeapChunk((AlignedHeapChunk.AlignedHeader) originalChunk);
         } else {
-            toSpace.promoteUnalignedHeapChunk((UnalignedHeapChunk.UnalignedHeader) originalChunk, originalSpace);
+            toSpace.promoteUnalignedHeapChunk((UnalignedHeapChunk.UnalignedHeader) originalChunk);
         }
         return true;
     }
 
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     private boolean fitsInSurvivors(HeapChunk.Header<?> chunk, boolean isAligned) {
         if (isAligned) {
             return alignedChunkFitsInSurvivors();
@@ -304,17 +306,20 @@ public final class YoungGeneration extends Generation {
         return unalignedChunkFitsInSurvivors((UnalignedHeapChunk.UnalignedHeader) chunk);
     }
 
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     private boolean alignedChunkFitsInSurvivors() {
         UnsignedWord sum = survivorsToSpacesAccounting.getChunkBytes().add(HeapParameters.getAlignedHeapChunkSize());
         return sum.belowOrEqual(GCImpl.getPolicy().getSurvivorSpacesCapacity());
     }
 
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     private boolean unalignedChunkFitsInSurvivors(UnalignedHeapChunk.UnalignedHeader chunk) {
         UnsignedWord size = UnalignedHeapChunk.getCommittedObjectMemory(chunk);
         UnsignedWord sum = survivorsToSpacesAccounting.getChunkBytes().add(size);
         return sum.belowOrEqual(GCImpl.getPolicy().getSurvivorSpacesCapacity());
     }
 
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     AlignedHeapChunk.AlignedHeader requestAlignedSurvivorChunk() {
         assert VMOperation.isGCInProgress() : "Should only be called from the collector.";
         if (!alignedChunkFitsInSurvivors()) {
diff --git a/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/graal/BarrierSnippets.java b/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/graal/BarrierSnippets.java
index 247da5e8440..69adc25a774 100644
--- a/graal/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/graal/BarrierSnippets.java
+++ b/graal/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/graal/BarrierSnippets.java
@@ -204,7 +204,7 @@ class BarrierSnippetCounters {
 class BarrierSnippetCountersFeature implements InternalFeature {
     @Override
     public boolean isInConfiguration(IsInConfigurationAccess access) {
-        return SubstrateOptions.UseSerialGC.getValue() && SubstrateOptions.useRememberedSet();
+        return SubstrateOptions.useSerialOrParallelGC() && SubstrateOptions.useRememberedSet();
     }
 
     @Override
diff --git a/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/graal/GenScavengeGCFeature.java b/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/graal/GenScavengeGCFeature.java
index 8216f42ead8..df035266567 100644
--- a/graal/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/graal/GenScavengeGCFeature.java
+++ b/graal/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/graal/GenScavengeGCFeature.java
@@ -46,6 +46,7 @@ import com.oracle.svm.core.genscavenge.HeapImplMemoryMXBean;
 import com.oracle.svm.core.genscavenge.ImageHeapInfo;
 import com.oracle.svm.core.genscavenge.IncrementalGarbageCollectorMXBean;
 import com.oracle.svm.core.genscavenge.LinearImageHeapLayouter;
+import com.oracle.svm.core.genscavenge.UseSerialOrEpsilonGC;
 import com.oracle.svm.core.genscavenge.jvmstat.EpsilonGCPerfData;
 import com.oracle.svm.core.genscavenge.jvmstat.SerialGCPerfData;
 import com.oracle.svm.core.genscavenge.remset.CardTableBasedRememberedSet;
@@ -71,7 +72,7 @@ import com.oracle.svm.core.jvmstat.PerfManager;
 class GenScavengeGCFeature implements InternalFeature {
     @Override
     public boolean isInConfiguration(IsInConfigurationAccess access) {
-        return new com.oracle.svm.core.genscavenge.UseSerialOrEpsilonGC().getAsBoolean();
+        return new UseSerialOrEpsilonGC().getAsBoolean();
     }
 
     @Override
@@ -160,7 +161,7 @@ class GenScavengeGCFeature implements InternalFeature {
     }
 
     private static PerfDataHolder createPerfData() {
-        if (SubstrateOptions.UseSerialGC.getValue()) {
+        if (SubstrateOptions.useSerialOrParallelGC()) {
             return new SerialGCPerfData();
         } else {
             assert SubstrateOptions.UseEpsilonGC.getValue();
diff --git a/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/jvmstat/SerialGCPerfData.java b/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/jvmstat/SerialGCPerfData.java
index 4fe4410401e..b9e72d73cc3 100644
--- a/graal/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/jvmstat/SerialGCPerfData.java
+++ b/graal/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/jvmstat/SerialGCPerfData.java
@@ -34,6 +34,7 @@ import com.oracle.svm.core.genscavenge.GCImpl;
 import com.oracle.svm.core.genscavenge.HeapAccounting;
 import com.oracle.svm.core.genscavenge.HeapImpl;
 import com.oracle.svm.core.genscavenge.HeapParameters;
+import com.oracle.svm.core.genscavenge.parallel.ParallelGC;
 import com.oracle.svm.core.jvmstat.PerfDataHolder;
 import com.oracle.svm.core.jvmstat.PerfLongConstant;
 import com.oracle.svm.core.jvmstat.PerfLongCounter;
@@ -45,6 +46,7 @@ import com.oracle.svm.core.jvmstat.PerfUnit;
 /**
  * Performance data for our serial GC.
  */
+// TODO (chaeubl): rename this class
 public class SerialGCPerfData implements PerfDataHolder {
     private final PerfDataGCPolicy gcPolicy;
     private final PerfDataCollector youngCollector;
@@ -78,7 +80,9 @@ public class SerialGCPerfData implements PerfDataHolder {
         gcPolicy.allocate();
 
         youngCollector.allocate("Serial young collection pauses");
-        oldCollector.allocate("Serial full collection pauses");
+
+        String oldCollectorName = ParallelGC.isEnabled() ? "Parallel" : "Serial";
+        oldCollector.allocate(oldCollectorName + " full collection pauses");
 
         youngGen.allocate("young");
         youngGen.spaces[0].allocate("eden");
diff --git a/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/parallel/ChunkQueue.java b/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/parallel/ChunkQueue.java
new file mode 100644
index 00000000000..15780625483
--- /dev/null
+++ b/graal/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/parallel/ChunkQueue.java
@@ -0,0 +1,109 @@
+/*
+ * Copyright (c) 2022, 2022, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2022, 2022, BELLSOFT. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package com.oracle.svm.core.genscavenge.parallel;
+
+import org.graalvm.compiler.api.replacements.Fold;
+import org.graalvm.nativeimage.ImageSingletons;
+import org.graalvm.nativeimage.Platform;
+import org.graalvm.nativeimage.Platforms;
+import org.graalvm.nativeimage.impl.UnmanagedMemorySupport;
+import org.graalvm.word.Pointer;
+import org.graalvm.word.WordFactory;
+
+import com.oracle.svm.core.Uninterruptible;
+import com.oracle.svm.core.config.ConfigurationValues;
+import com.oracle.svm.core.thread.VMThreads;
+import com.oracle.svm.core.util.VMError;
+
+/**
+ * A queue that stores pointers into "grey" heap chunks that need to be scanned. Note that the
+ * pointers don't necessarily point to the beginning of a chunk. GC workers threads may only access
+ * the queue if they hold {@link ParallelGC#getMutex()}.
+ */
+public class ChunkQueue {
+    private static final int INITIAL_SIZE = 1024 * wordSize();
+
+    private Pointer buffer;
+    private int size;
+    private int top;
+
+    @Fold
+    static int wordSize() {
+        return ConfigurationValues.getTarget().wordSize;
+    }
+
+    @Platforms(Platform.HOSTED_ONLY.class)
+    ChunkQueue() {
+    }
+
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
+    public void initialize() {
+        assert top == 0 && size == 0 && buffer.isNull();
+        top = 0;
+        size = INITIAL_SIZE;
+        buffer = ImageSingletons.lookup(UnmanagedMemorySupport.class).malloc(WordFactory.unsigned(size));
+        VMError.guarantee(buffer.isNonNull(), "Failed to allocate native memory for the ChunkBuffer.");
+    }
+
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
+    void push(Pointer ptr) {
+        assert !ParallelGC.singleton().isInParallelPhase() && VMThreads.ownsThreadMutex() || ParallelGC.singleton().isInParallelPhase() && ParallelGC.singleton().getMutex().isOwner(true);
+        assert ptr.isNonNull();
+        if (top >= size) {
+            size *= 2;
+            assert top < size;
+            buffer = ImageSingletons.lookup(UnmanagedMemorySupport.class).realloc(buffer, WordFactory.unsigned(size));
+            VMError.guarantee(buffer.isNonNull(), "Failed to allocate native memory for the ChunkBuffer.");
+        }
+        buffer.writeWord(top, ptr);
+        top += wordSize();
+    }
+
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
+    Pointer pop() {
+        assert ParallelGC.singleton().isInParallelPhase() && ParallelGC.singleton().getMutex().isOwner(true);
+        if (top > 0) {
+            top -= wordSize();
+            return buffer.readWord(top);
+        }
+        return WordFactory.nullPointer();
+    }
+
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
+    boolean isEmpty() {
+        assert !ParallelGC.singleton().isInParallelPhase();
+        return top == 0;
+    }
+
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
+    void teardown() {
+        ImageSingletons.lookup(UnmanagedMemorySupport.class).free(buffer);
+        buffer = WordFactory.nullPointer();
+        size = 0;
+        top = 0;
+    }
+}
diff --git a/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/parallel/ParallelGC.java b/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/parallel/ParallelGC.java
new file mode 100644
index 00000000000..adc975f414d
--- /dev/null
+++ b/graal/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/parallel/ParallelGC.java
@@ -0,0 +1,587 @@
+/*
+ * Copyright (c) 2022, 2022, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2022, 2022, BELLSOFT. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+package com.oracle.svm.core.genscavenge.parallel;
+
+import java.util.function.BooleanSupplier;
+
+import org.graalvm.compiler.api.replacements.Fold;
+import org.graalvm.nativeimage.CurrentIsolate;
+import org.graalvm.nativeimage.ImageSingletons;
+import org.graalvm.nativeimage.Platform;
+import org.graalvm.nativeimage.Platforms;
+import org.graalvm.nativeimage.c.function.CEntryPoint;
+import org.graalvm.nativeimage.c.function.CEntryPointLiteral;
+import org.graalvm.nativeimage.c.function.CFunctionPointer;
+import org.graalvm.nativeimage.c.struct.RawPointerTo;
+import org.graalvm.nativeimage.c.struct.RawStructure;
+import org.graalvm.nativeimage.c.struct.SizeOf;
+import org.graalvm.word.Pointer;
+import org.graalvm.word.PointerBase;
+import org.graalvm.word.UnsignedWord;
+import org.graalvm.word.WordFactory;
+
+import com.oracle.svm.core.NeverInline;
+import com.oracle.svm.core.SubstrateGCOptions;
+import com.oracle.svm.core.SubstrateOptions;
+import com.oracle.svm.core.Uninterruptible;
+import com.oracle.svm.core.UnmanagedMemoryUtil;
+import com.oracle.svm.core.c.function.CEntryPointOptions;
+import com.oracle.svm.core.config.ConfigurationValues;
+import com.oracle.svm.core.feature.AutomaticallyRegisteredFeature;
+import com.oracle.svm.core.feature.InternalFeature;
+import com.oracle.svm.core.genscavenge.AlignedHeapChunk;
+import com.oracle.svm.core.genscavenge.GCImpl;
+import com.oracle.svm.core.genscavenge.GreyToBlackObjectVisitor;
+import com.oracle.svm.core.genscavenge.HeapChunk;
+import com.oracle.svm.core.genscavenge.HeapParameters;
+import com.oracle.svm.core.genscavenge.UnalignedHeapChunk;
+import com.oracle.svm.core.genscavenge.remset.RememberedSet;
+import com.oracle.svm.core.graal.nodes.WriteCurrentVMThreadNode;
+import com.oracle.svm.core.graal.snippets.CEntryPointSnippets;
+import com.oracle.svm.core.jdk.Jvm;
+import com.oracle.svm.core.jdk.UninterruptibleUtils;
+import com.oracle.svm.core.locks.VMCondition;
+import com.oracle.svm.core.locks.VMMutex;
+import com.oracle.svm.core.log.Log;
+import com.oracle.svm.core.option.SubstrateOptionKey;
+import com.oracle.svm.core.os.CommittedMemoryProvider;
+import com.oracle.svm.core.thread.PlatformThreads;
+import com.oracle.svm.core.thread.VMThreads.OSThreadHandle;
+import com.oracle.svm.core.thread.PlatformThreads.OSThreadHandlePointer;
+import com.oracle.svm.core.thread.PlatformThreads.ThreadLocalKey;
+import com.oracle.svm.core.util.UserError;
+import com.oracle.svm.core.util.VMError;
+
+/**
+ * A garbage collector that tries to shorten GC pauses by using multiple worker threads. Currently,
+ * the only phase supported is scanning grey objects during a full GC. The number of worker threads
+ * can be set with a runtime option (see {@link SubstrateOptions#ParallelGCThreads}).
+ * <p>
+ * The GC worker threads are unattached threads that are started lazily and that call AOT-compiled
+ * code. So, they don't have an {@link org.graalvm.nativeimage.IsolateThread} data structure and
+ * don't participate in the safepoint handling.
+ * <p>
+ * Worker threads use heap chunks as the unit of work. Chunks to be scanned are stored in the
+ * {@link ChunkQueue}. Worker threads pop chunks from the queue and scan them for references to live
+ * objects to be promoted. When promoting an aligned chunk object, they speculatively allocate
+ * memory for its copy in the to-space, then compete to install forwarding pointer in the original
+ * object. The winning thread proceeds to copy object data, losing threads retract the speculatively
+ * allocated memory.
+ * <p>
+ * Each worker thread allocates memory in its own thread local allocation chunk for speed. As
+ * allocation chunks become filled up, they are pushed to {@link ChunkQueue}. This pop-scan-push
+ * cycle continues until the chunk buffer becomes empty. At this point, worker threads are parked
+ * and the GC routine continues on the main GC thread.
+ */
+public class ParallelGC {
+    private enum Phase {
+        SEQUENTIAL,
+        PARALLEL,
+        CLEANUP,
+        SHUTDOWN,
+    }
+
+    public static final int SCAN_CARD_TABLE = 0b000;
+    public static final int SCAN_GREY_OBJECTS = 0b010;
+
+    private static final int SCAN_OP_MASK = 0b010;
+    private static final int UNALIGNED_BIT = 0b001;
+    private static final UnsignedWord POINTER_MASK = WordFactory.unsigned(0b111).not();
+
+    private static final int MAX_WORKER_THREADS = 8;
+
+    /**
+     * Worker thread states occupy separate cache lines to avoid false sharing.
+     * We assume 128 bytes (16 words) cache line here.
+     */
+    private static final int CACHE_LINE_WORDS = 16;
+
+    private final VMMutex mutex = new VMMutex("parallelGC");
+    private final VMCondition seqPhase = new VMCondition(mutex);
+    private final VMCondition parPhase = new VMCondition(mutex);
+    private final ChunkQueue chunkQueue = new ChunkQueue();
+    private final CEntryPointLiteral<CFunctionPointer> gcWorkerRunFunc = CEntryPointLiteral.create(ParallelGC.class, "gcWorkerRun", GCWorkerThreadState.class);
+
+    private boolean initialized;
+    private ThreadLocalKey workerStateTL;
+    private GCWorkerThreadState workerStates;
+    private UnsignedWord workerStatesSize;
+    private OSThreadHandlePointer workerThreads;
+    private int numWorkerThreads;
+    private int busyWorkerThreads;
+    private volatile Phase phase;
+
+    @Platforms(Platform.HOSTED_ONLY.class)
+    public ParallelGC() {
+    }
+
+    @Fold
+    public static ParallelGC singleton() {
+        return ImageSingletons.lookup(ParallelGC.class);
+    }
+
+    @Fold
+    public static boolean isEnabled() {
+        return SubstrateOptions.UseParallelGC.getValue();
+    }
+
+    @Fold
+    static int wordSize() {
+        return ConfigurationValues.getTarget().wordSize;
+    }
+
+    @Uninterruptible(reason = "Called from a GC worker thread.")
+    public boolean isInParallelPhase() {
+        return phase == Phase.PARALLEL;
+    }
+
+    @Uninterruptible(reason = "Called from a GC worker thread.")
+    public VMMutex getMutex() {
+        return mutex;
+    }
+
+    @Uninterruptible(reason = "Called from a GC worker thread.")
+    public Pointer getAllocChunkScanPointer(int age, boolean clear) {
+        GCWorkerThreadState state = getWorkerThreadState();
+        Pointer chunk = (Pointer) state.read(age);
+        if (clear) {
+            state.write(age, WordFactory.nullPointer());
+        }
+        return chunk;
+    }
+
+    @Uninterruptible(reason = "Called from a GC worker thread.")
+    public void setAllocChunk(int age, AlignedHeapChunk.AlignedHeader allocChunk) {
+        Pointer scanPtr = WordFactory.nullPointer();
+        if (allocChunk.isNonNull()) {
+            Pointer top = HeapChunk.getTopPointer(allocChunk);
+            // Use chunk as allocation chunk unless it is full (top == end)
+            if (top.belowThan(HeapChunk.getEndPointer(allocChunk))) {
+                scanPtr = top;
+            }
+        }
+        getWorkerThreadState().write(age, scanPtr);
+    }
+
+    @Uninterruptible(reason = "Called from a GC worker thread.")
+    public void push(AlignedHeapChunk.AlignedHeader aChunk, int scanOp) {
+        Pointer ptr = scanOp == SCAN_GREY_OBJECTS ? AlignedHeapChunk.getObjectsStart(aChunk) : HeapChunk.asPointer(aChunk);
+        push(ptr, scanOp);
+    }
+
+    @Uninterruptible(reason = "Called from a GC worker thread.")
+    public void push(UnalignedHeapChunk.UnalignedHeader uChunk, int scanOp) {
+        push(HeapChunk.asPointer(uChunk).or(ParallelGC.UNALIGNED_BIT), scanOp);
+    }
+
+    @Uninterruptible(reason = "Called from a GC worker thread.")
+    private void push(Pointer ptr, int scanOp) {
+        assert ptr.isNonNull();
+        ptr = ptr.or(scanOp);
+        chunkQueue.push(ptr);
+        if (phase == Phase.PARALLEL) {
+            assert mutex.isOwner(true);
+            parPhase.signal();
+        }
+    }
+
+    @Uninterruptible(reason = "Called from a GC worker thread.")
+    public void pushAllocChunk(Pointer ptr) {
+        /*
+         * Scanning (and therefore enqueueing) is only necessary if there are any not yet scanned
+         * objects in the chunk.
+         */
+        assert isEnabled() && ptr.isNonNull();
+        GCWorkerThreadState state = getWorkerThreadState();
+        AlignedHeapChunk.AlignedHeader chunk = AlignedHeapChunk.getEnclosingChunkFromObjectPointer(ptr);
+        if (chunk.notEqual(getScannedChunk(state)) && HeapChunk.getTopPointer(chunk).aboveThan(ptr)) {
+            push(ptr, SCAN_GREY_OBJECTS);
+        }
+    }
+
+    @Uninterruptible(reason = "Called from a GC worker thread.")
+    private GCWorkerThreadState getWorkerThreadState() {
+        if (CurrentIsolate.getCurrentThread().isNull()) {
+            return PlatformThreads.singleton().getUnmanagedThreadLocalValue(workerStateTL);
+        }
+        return workerStates;
+    }
+
+    public void initialize() {
+        if (initialized) {
+            return;
+        }
+
+        initialized = true;
+        phase = Phase.PARALLEL;
+
+        chunkQueue.initialize();
+        workerStateTL = PlatformThreads.singleton().createUnmanagedThreadLocal();
+        numWorkerThreads = busyWorkerThreads = getWorkerCount();
+
+        /* Round worker thread state size up to CACHE_LINE_WORDS */
+        int workerStateWords = (getStateWords() + CACHE_LINE_WORDS - 1) / CACHE_LINE_WORDS * CACHE_LINE_WORDS;
+        /* Allocate one struct per worker thread and one struct for the main GC thread. */
+        int numWorkerStates = numWorkerThreads + 1;
+        workerStatesSize = WordFactory.unsigned(workerStateWords * numWorkerStates * wordSize());
+        workerStates = (GCWorkerThreadState) CommittedMemoryProvider.get()
+                .allocateAlignedChunk(workerStatesSize, WordFactory.unsigned(CACHE_LINE_WORDS * wordSize()));
+        VMError.guarantee(workerStates.isNonNull());
+
+        /* Start the worker threads and wait until they are in a well-defined state. */
+        workerThreads = (OSThreadHandlePointer) CommittedMemoryProvider.get()
+                .allocateUnalignedChunk(SizeOf.unsigned(OSThreadHandlePointer.class).multiply(numWorkerThreads));
+        VMError.guarantee(workerThreads.isNonNull());
+        for (int i = 0; i < numWorkerThreads; i++) {
+            GCWorkerThreadState workerState = workerStates.addressOf(workerStateWords * (i + 1));
+            /* Reuse scanned chunk slot for the isolate since it is read just once at thread start */
+            setScannedChunk(workerState, CurrentIsolate.getIsolate());
+            OSThreadHandle thread = PlatformThreads.singleton().startThreadUnmanaged(gcWorkerRunFunc.getFunctionPointer(), workerState, 0);
+            workerThreads.write(i, thread);
+        }
+        waitUntilWorkerThreadsFinish();
+    }
+
+    @Uninterruptible(reason = "Tear-down in progress.")
+    public void tearDown() {
+        if (!initialized) {
+            return;
+        }
+
+        initialized = false;
+        chunkQueue.teardown();
+
+        /* Signal the worker threads so that they can shut down. */
+        phase = Phase.SHUTDOWN;
+        parPhase.broadcast();
+
+        for (int i = 0; i < numWorkerThreads; i++) {
+            OSThreadHandle thread = workerThreads.read(i);
+            PlatformThreads.singleton().joinThreadUnmanaged(thread);
+        }
+        busyWorkerThreads = 0;
+
+        CommittedMemoryProvider.get().freeAlignedChunk(workerStates, workerStatesSize, WordFactory.unsigned(CACHE_LINE_WORDS * wordSize()));
+        CommittedMemoryProvider.get().freeUnalignedChunk(workerThreads, SizeOf.unsigned(OSThreadHandlePointer.class).multiply(numWorkerThreads));
+        workerThreads = WordFactory.nullPointer();
+
+        PlatformThreads.singleton().deleteUnmanagedThreadLocal(workerStateTL);
+        workerStateTL = WordFactory.nullPointer();
+        numWorkerThreads = 0;
+
+        /*
+         * Free any chunks left in the chunk releaser. This needs locking because a worker thread
+         * might be doing this in parallel. */
+        mutex.lockNoTransitionUnspecifiedOwner();
+        try {
+            doCleanup();
+        } finally {
+            mutex.unlockNoTransitionUnspecifiedOwner();
+        }
+    }
+
+    private static int getWorkerCount() {
+        int setting = SubstrateOptions.ParallelGCThreads.getValue();
+        int workerCount = setting > 0 ? setting : getDefaultWorkerCount();
+        verboseGCLog().string("[Number of ParallelGC threads: ").unsigned(workerCount).string("]").newline();
+        return workerCount;
+    }
+
+    private static int getDefaultWorkerCount() {
+        /* This does not take the container support into account. */
+        int cpus = Jvm.JVM_ActiveProcessorCount();
+        return UninterruptibleUtils.Math.min(cpus, MAX_WORKER_THREADS);
+    }
+
+    @Uninterruptible(reason = "Heap base is not set up yet.")
+    @CEntryPoint(include = UseParallelGC.class, publishAs = CEntryPoint.Publish.NotPublished)
+    @CEntryPointOptions(prologue = GCWorkerThreadPrologue.class, epilogue = CEntryPointOptions.NoEpilogue.class)
+    private static void gcWorkerRun(GCWorkerThreadState state) {
+        try {
+            ParallelGC.singleton().work(state);
+        } catch (Throwable e) {
+            throw VMError.shouldNotReachHere(e);
+        }
+    }
+
+    @NeverInline("Prevent reads from floating up.")
+    @Uninterruptible(reason = "Called from a GC worker thread.")
+    private void work(GCWorkerThreadState state) {
+        PlatformThreads.singleton().setUnmanagedThreadLocalValue(workerStateTL, state);
+        try {
+            work0(state);
+        } catch (Throwable e) {
+            VMError.shouldNotReachHere(e);
+        }
+    }
+
+    @Uninterruptible(reason = "Called from a GC worker thread.")
+    private void work0(GCWorkerThreadState state) {
+        while (phase != Phase.SHUTDOWN) {
+            Pointer ptr;
+            mutex.lockNoTransitionUnspecifiedOwner();
+            try {
+                ptr = chunkQueue.pop();
+                /* Block if there is no local/global work. */
+                if (ptr.isNull() && getNextAllocChunkScanPointer(false).isNull()) {
+                    decrementBusyWorkers();
+                    do {
+                        parPhase.blockNoTransitionUnspecifiedOwner();
+                        attemptCleanup();
+                    } while (phase == Phase.SEQUENTIAL);
+                    incrementBusyWorkers();
+                }
+            } finally {
+                mutex.unlockNoTransitionUnspecifiedOwner();
+            }
+
+            if (ptr.isNonNull()) {
+                scanChunk(ptr);
+            } else {
+                scanAllocChunk(state);
+            }
+        }
+    }
+
+    @Uninterruptible(reason = "Called from a GC worker thread.")
+    private static void scanChunk(Pointer ptr) {
+        assert ptr.isNonNull();
+        boolean aligned = ptr.and(UNALIGNED_BIT).notEqual(UNALIGNED_BIT);
+        UnsignedWord op = ptr.and(SCAN_OP_MASK);
+        ptr = ptr.and(POINTER_MASK);
+        GreyToBlackObjectVisitor visitor = GCImpl.getGCImpl().getGreyToBlackObjectVisitor();
+        if (op.equal(SCAN_CARD_TABLE)) {
+            if (aligned) {
+                AlignedHeapChunk.AlignedHeader aChunk = (AlignedHeapChunk.AlignedHeader) ptr;
+                RememberedSet.get().walkDirtyObjects(aChunk, visitor, true);
+            } else {
+                UnalignedHeapChunk.UnalignedHeader uChunk = (UnalignedHeapChunk.UnalignedHeader) ptr;
+                RememberedSet.get().walkDirtyObjects(uChunk, visitor, true);
+            }
+        } else if (op.equal(SCAN_GREY_OBJECTS)) {
+            if (aligned) {
+                AlignedHeapChunk.AlignedHeader aChunk = AlignedHeapChunk.getEnclosingChunkFromObjectPointer(ptr);
+                HeapChunk.walkObjectsFromInline(aChunk, ptr, visitor);
+            } else {
+                UnalignedHeapChunk.UnalignedHeader uChunk = (UnalignedHeapChunk.UnalignedHeader) ptr;
+                UnalignedHeapChunk.walkObjectsInline(uChunk, visitor);
+            }
+        } else {
+            VMError.shouldNotReachHere("Unknown opcode");
+        }
+    }
+
+    @Uninterruptible(reason = "Called from a GC worker thread.")
+    private void scanAllocChunk(GCWorkerThreadState state) {
+        Pointer scanPtr = getNextAllocChunkScanPointer(false);
+        if (scanPtr.isNonNull()) {
+            AlignedHeapChunk.AlignedHeader allocChunk = AlignedHeapChunk.getEnclosingChunkFromObjectPointer(scanPtr);
+            setScannedChunk(state, allocChunk);
+            allocChunk.getSpace().walkAllocChunk(allocChunk, scanPtr, GCImpl.getGCImpl().getGreyToBlackObjectVisitor());
+            setScannedChunk(state, WordFactory.nullPointer());
+        }
+    }
+
+    @Uninterruptible(reason = "Called from a GC worker thread.")
+    private Pointer getNextAllocChunkScanPointer(boolean clear) {
+        for (int i = 1; i < getStateWords(); i++) {
+            Pointer scanPtr = getAllocChunkScanPointer(i, clear);
+            if (scanPtr.isNonNull()) {
+                AlignedHeapChunk.AlignedHeader allocChunk = AlignedHeapChunk.getEnclosingChunkFromObjectPointer(scanPtr);
+                if (HeapChunk.getTopPointer(allocChunk).aboveThan(scanPtr)) {
+                    return scanPtr;
+                }
+            }
+        }
+        return WordFactory.nullPointer();
+    }
+
+    @Uninterruptible(reason = "Called from a GC worker thread.")
+    private void incrementBusyWorkers() {
+        assert mutex.isOwner(true);
+        ++busyWorkerThreads;
+    }
+
+    @Uninterruptible(reason = "Called from a GC worker thread.")
+    private void decrementBusyWorkers() {
+        assert mutex.isOwner(true);
+        if (--busyWorkerThreads == 0) {
+            phase = Phase.SEQUENTIAL;
+            seqPhase.signal();
+        }
+    }
+
+    /**
+     * Start parallel phase and wait until all chunks have been processed.
+     */
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
+    public void scheduleScan() {
+        /* Push all alloc chunks filled during sequential phase */
+        Pointer allocChunk;
+        while ((allocChunk = getNextAllocChunkScanPointer(true)).isNonNull()) {
+            push(allocChunk, SCAN_GREY_OBJECTS);
+        }
+
+        /* Reset all thread local states. */
+        UnmanagedMemoryUtil.fillLongs((Pointer) workerStates, workerStatesSize, 0L);
+
+        mutex.lockNoTransitionUnspecifiedOwner();
+        try {
+            /* A cleanup might have been scheduled. Wait for it to finish. */
+            waitUntilWorkerThreadsFinish0();
+
+            /* Let worker threads run. */
+            phase = Phase.PARALLEL;
+            parPhase.broadcast();
+
+            waitUntilWorkerThreadsFinish0();
+        } finally {
+            mutex.unlockNoTransitionUnspecifiedOwner();
+        }
+
+        assert chunkQueue.isEmpty();
+        assert phase != Phase.PARALLEL;
+        assert busyWorkerThreads == 0;
+    }
+
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
+    private void waitUntilWorkerThreadsFinish() {
+        mutex.lockNoTransitionUnspecifiedOwner();
+        try {
+            waitUntilWorkerThreadsFinish0();
+        } finally {
+            mutex.unlockNoTransitionUnspecifiedOwner();
+        }
+    }
+
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
+    private void waitUntilWorkerThreadsFinish0() {
+        while (phase != Phase.SEQUENTIAL) {
+            seqPhase.blockNoTransitionUnspecifiedOwner();
+        }
+    }
+
+    public void scheduleCleanup() {
+        mutex.lock();
+        try {
+            phase = Phase.CLEANUP;
+            parPhase.signal();
+        } finally {
+            mutex.unlock();
+        }
+    }
+
+    @Uninterruptible(reason = "Called from a GC worker thread.")
+    private void attemptCleanup() {
+        if (phase == Phase.CLEANUP) {
+            doCleanup();
+            phase = Phase.SEQUENTIAL;
+            seqPhase.signal();
+        }
+    }
+
+    @Uninterruptible(reason = "Called from a GC worker thread.")
+    private void doCleanup() {
+        assert mutex.isOwner(true) || phase == Phase.SHUTDOWN;
+        GCImpl.getGCImpl().freeChunks();
+    }
+
+    private static Log verboseGCLog() {
+        return SubstrateGCOptions.VerboseGC.getValue() ? Log.log() : Log.noopLog();
+    }
+
+    /*
+     * Worker thread state is a bunch of chunk pointers laid out in the following manner:
+     * word 0   :  scanned chunk pointer, also reused for isolate pointer at the very start of a thread
+     *      1   :
+     *  ...     :  survivor states' allocation pointers
+     *      N   :
+     *      N+1 :  old gen allocation pointer
+     */
+    @RawPointerTo(GCWorkerThreadState.AlignedChunkPointer.class)
+    interface GCWorkerThreadState extends PointerBase {
+        @RawStructure
+        interface AlignedChunkPointer extends PointerBase {}
+
+        PointerBase read(int age);
+        void write(int age, PointerBase value);
+        GCWorkerThreadState addressOf(int index);
+    }
+
+    @Fold
+    static int getStateWords() {
+        return HeapParameters.getMaxSurvivorSpaces() + 2;
+    }
+
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
+    private static PointerBase getScannedChunk(GCWorkerThreadState state) {
+        return state.read(0);
+    }
+
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
+    private static void setScannedChunk(GCWorkerThreadState state, PointerBase chunkPointer) {
+        state.write(0, chunkPointer);
+    }
+
+    private static class GCWorkerThreadPrologue implements CEntryPointOptions.Prologue {
+        @Uninterruptible(reason = "prologue")
+        @SuppressWarnings("unused")
+        public static void enter(GCWorkerThreadState state) {
+            CEntryPointSnippets.setHeapBase(getScannedChunk(state));
+            WriteCurrentVMThreadNode.writeCurrentVMThread(WordFactory.nullPointer());
+        }
+    }
+
+    private static class UseParallelGC implements BooleanSupplier {
+        @Override
+        public boolean getAsBoolean() {
+            return ParallelGC.isEnabled();
+        }
+    }
+}
+
+@Platforms(Platform.HOSTED_ONLY.class)
+@AutomaticallyRegisteredFeature()
+@SuppressWarnings("unused")
+class ParallelGCFeature implements InternalFeature {
+    @Override
+    public boolean isInConfiguration(IsInConfigurationAccess access) {
+        return ParallelGC.isEnabled();
+    }
+
+    @Override
+    public void afterRegistration(AfterRegistrationAccess access) {
+        verifyOptionEnabled(SubstrateOptions.SpawnIsolates);
+
+        ImageSingletons.add(ParallelGC.class, new ParallelGC());
+    }
+
+    private static void verifyOptionEnabled(SubstrateOptionKey<Boolean> option) {
+        String optionMustBeEnabledFmt = "When using the parallel garbage collector ('--gc=parallel'), please note that option '%s' must be enabled.";
+        UserError.guarantee(option.getValue(), optionMustBeEnabledFmt, option.getName());
+    }
+}
diff --git a/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/remset/AlignedChunkRememberedSet.java b/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/remset/AlignedChunkRememberedSet.java
index d244d47c7cb..8c678b33e9a 100644
--- a/graal/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/remset/AlignedChunkRememberedSet.java
+++ b/graal/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/remset/AlignedChunkRememberedSet.java
@@ -37,6 +37,7 @@ import org.graalvm.word.UnsignedWord;
 import org.graalvm.word.WordFactory;
 
 import com.oracle.svm.core.AlwaysInline;
+import com.oracle.svm.core.Uninterruptible;
 import com.oracle.svm.core.config.ConfigurationValues;
 import com.oracle.svm.core.genscavenge.AlignedHeapChunk;
 import com.oracle.svm.core.genscavenge.AlignedHeapChunk.AlignedHeader;
@@ -86,6 +87,7 @@ final class AlignedChunkRememberedSet {
     }
 
     @AlwaysInline("GC performance")
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     public static void enableRememberedSetForObject(AlignedHeader chunk, Object obj) {
         Pointer fotStart = getFirstObjectTableStart(chunk);
         Pointer objectsStart = AlignedHeapChunk.getObjectsStart(chunk);
@@ -95,6 +97,7 @@ final class AlignedChunkRememberedSet {
         ObjectHeaderImpl.setRememberedSetBit(obj);
     }
 
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     public static void enableRememberedSet(AlignedHeader chunk) {
         // Completely clean the card table and the first object table as further objects may be
         // added later on to this chunk.
@@ -110,6 +113,7 @@ final class AlignedChunkRememberedSet {
         }
     }
 
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     public static void clearRememberedSet(AlignedHeader chunk) {
         CardTable.cleanTable(getCardTableStart(chunk), getCardTableSize());
     }
@@ -118,6 +122,7 @@ final class AlignedChunkRememberedSet {
      * Dirty the card corresponding to the given Object. This has to be fast, because it is used by
      * the post-write barrier.
      */
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     public static void dirtyCardForObject(Object object, boolean verifyOnly) {
         Pointer objectPointer = Word.objectToUntrackedPointer(object);
         AlignedHeader chunk = AlignedHeapChunk.getEnclosingChunkFromObjectPointer(objectPointer);
@@ -130,6 +135,7 @@ final class AlignedChunkRememberedSet {
         }
     }
 
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     public static void walkDirtyObjects(AlignedHeader chunk, GreyToBlackObjectVisitor visitor, boolean clean) {
         Pointer objectsStart = AlignedHeapChunk.getObjectsStart(chunk);
         Pointer objectsLimit = HeapChunk.getTopPointer(chunk);
@@ -183,6 +189,7 @@ final class AlignedChunkRememberedSet {
         }
     }
 
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     private static void walkObjects(AlignedHeader chunk, Pointer start, Pointer end, GreyToBlackObjectVisitor visitor) {
         Pointer fotStart = getFirstObjectTableStart(chunk);
         Pointer objectsStart = AlignedHeapChunk.getObjectsStart(chunk);
@@ -203,6 +210,7 @@ final class AlignedChunkRememberedSet {
     }
 
     /** Return the index of an object within the tables of a chunk. */
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     private static UnsignedWord getObjectIndex(AlignedHeader chunk, Pointer objectPointer) {
         UnsignedWord offset = AlignedHeapChunk.getObjectOffset(chunk, objectPointer);
         return CardTable.memoryOffsetToIndex(offset);
@@ -260,18 +268,22 @@ final class AlignedChunkRememberedSet {
         return UnsignedUtils.roundUp(tableLimit, alignment);
     }
 
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     private static Pointer getCardTableStart(AlignedHeader chunk) {
         return getCardTableStart(HeapChunk.asPointer(chunk));
     }
 
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     private static Pointer getCardTableStart(Pointer chunk) {
         return chunk.add(getCardTableStartOffset());
     }
 
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     private static Pointer getFirstObjectTableStart(AlignedHeader chunk) {
         return getFirstObjectTableStart(HeapChunk.asPointer(chunk));
     }
 
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     private static Pointer getFirstObjectTableStart(Pointer chunk) {
         return chunk.add(getFirstObjectTableStartOffset());
     }
diff --git a/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/remset/CardTable.java b/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/remset/CardTable.java
index fa707695db9..d49928864d3 100644
--- a/graal/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/remset/CardTable.java
+++ b/graal/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/remset/CardTable.java
@@ -33,6 +33,7 @@ import org.graalvm.word.Pointer;
 import org.graalvm.word.UnsignedWord;
 import org.graalvm.word.WordFactory;
 
+import com.oracle.svm.core.Uninterruptible;
 import com.oracle.svm.core.UnmanagedMemoryUtil;
 import com.oracle.svm.core.genscavenge.HeapChunk;
 import com.oracle.svm.core.genscavenge.HeapImpl;
@@ -83,10 +84,12 @@ final class CardTable {
     private CardTable() {
     }
 
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     public static void cleanTable(Pointer tableStart, UnsignedWord size) {
         UnmanagedMemoryUtil.fill(tableStart, size, CLEAN_ENTRY);
     }
 
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     public static void setDirty(Pointer table, UnsignedWord index) {
         byte valueBefore = table.readByte(index, BarrierSnippets.CARD_REMEMBERED_SET_LOCATION);
         // Using a likely probability should typically avoid placing the write below at a separate
@@ -96,10 +99,12 @@ final class CardTable {
         }
     }
 
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     public static void setClean(Pointer table, UnsignedWord index) {
         table.writeByte(index, CLEAN_ENTRY, BarrierSnippets.CARD_REMEMBERED_SET_LOCATION);
     }
 
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     public static boolean isDirty(Pointer table, UnsignedWord index) {
         int entry = readEntry(table, index);
         return entry == DIRTY_ENTRY;
@@ -110,23 +115,28 @@ final class CardTable {
         return entry == CLEAN_ENTRY;
     }
 
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     private static int readEntry(Pointer table, UnsignedWord index) {
         return table.readByte(index);
     }
 
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     public static UnsignedWord memoryOffsetToIndex(UnsignedWord offset) {
         return offset.unsignedDivide(BYTES_COVERED_BY_ENTRY);
     }
 
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     public static Pointer cardToHeapAddress(Pointer cardTableStart, Pointer cardAddr, Pointer objectsStart) {
         UnsignedWord offset = cardAddr.subtract(cardTableStart).multiply(CardTable.BYTES_COVERED_BY_ENTRY);
         return objectsStart.add(offset);
     }
 
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     public static UnsignedWord tableSizeForMemorySize(UnsignedWord memorySize) {
         return indexLimitForMemorySize(memorySize);
     }
 
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     public static UnsignedWord indexLimitForMemorySize(UnsignedWord memorySize) {
         UnsignedWord roundedMemory = UnsignedUtils.roundUp(memorySize, WordFactory.unsigned(BYTES_COVERED_BY_ENTRY));
         return CardTable.memoryOffsetToIndex(roundedMemory);
diff --git a/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/remset/CardTableBasedRememberedSet.java b/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/remset/CardTableBasedRememberedSet.java
index 40ec1153d28..c662b3c1bf4 100644
--- a/graal/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/remset/CardTableBasedRememberedSet.java
+++ b/graal/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/remset/CardTableBasedRememberedSet.java
@@ -32,6 +32,7 @@ import org.graalvm.nativeimage.Platforms;
 import org.graalvm.word.UnsignedWord;
 
 import com.oracle.svm.core.AlwaysInline;
+import com.oracle.svm.core.Uninterruptible;
 import com.oracle.svm.core.genscavenge.AlignedHeapChunk.AlignedHeader;
 import com.oracle.svm.core.genscavenge.GCImpl;
 import com.oracle.svm.core.genscavenge.GreyToBlackObjectVisitor;
@@ -42,6 +43,7 @@ import com.oracle.svm.core.genscavenge.ObjectHeaderImpl;
 import com.oracle.svm.core.genscavenge.Space;
 import com.oracle.svm.core.genscavenge.UnalignedHeapChunk.UnalignedHeader;
 import com.oracle.svm.core.genscavenge.graal.SubstrateCardTableBarrierSet;
+import com.oracle.svm.core.genscavenge.parallel.ParallelGC;
 import com.oracle.svm.core.image.ImageHeapObject;
 import com.oracle.svm.core.util.HostedByteBufferPointer;
 
@@ -86,33 +88,39 @@ public class CardTableBasedRememberedSet implements RememberedSet {
     }
 
     @Override
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     public void enableRememberedSetForChunk(AlignedHeader chunk) {
         AlignedChunkRememberedSet.enableRememberedSet(chunk);
     }
 
     @Override
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     public void enableRememberedSetForChunk(UnalignedHeader chunk) {
         UnalignedChunkRememberedSet.enableRememberedSet(chunk);
     }
 
     @Override
     @AlwaysInline("GC performance")
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     public void enableRememberedSetForObject(AlignedHeader chunk, Object obj) {
         AlignedChunkRememberedSet.enableRememberedSetForObject(chunk, obj);
     }
 
     @Override
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     public void clearRememberedSet(AlignedHeader chunk) {
         AlignedChunkRememberedSet.clearRememberedSet(chunk);
     }
 
     @Override
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     public void clearRememberedSet(UnalignedHeader chunk) {
         UnalignedChunkRememberedSet.clearRememberedSet(chunk);
     }
 
     @Override
     @AlwaysInline("GC performance")
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     public boolean hasRememberedSet(UnsignedWord header) {
         return ObjectHeaderImpl.hasRememberedSet(header);
     }
@@ -131,6 +139,7 @@ public class CardTableBasedRememberedSet implements RememberedSet {
 
     @Override
     @AlwaysInline("GC performance")
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     public void dirtyCardIfNecessary(Object holderObject, Object object) {
         if (holderObject == null || object == null) {
             return;
@@ -163,26 +172,37 @@ public class CardTableBasedRememberedSet implements RememberedSet {
     }
 
     @Override
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     public void walkDirtyObjects(AlignedHeader chunk, GreyToBlackObjectVisitor visitor, boolean clean) {
         AlignedChunkRememberedSet.walkDirtyObjects(chunk, visitor, clean);
     }
 
     @Override
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     public void walkDirtyObjects(UnalignedHeader chunk, GreyToBlackObjectVisitor visitor, boolean clean) {
         UnalignedChunkRememberedSet.walkDirtyObjects(chunk, visitor, clean);
     }
 
     @Override
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     public void walkDirtyObjects(Space space, GreyToBlackObjectVisitor visitor, boolean clean) {
         AlignedHeader aChunk = space.getFirstAlignedHeapChunk();
         while (aChunk.isNonNull()) {
-            walkDirtyObjects(aChunk, visitor, clean);
+            if (ParallelGC.isEnabled()) {
+                ParallelGC.singleton().push(aChunk, ParallelGC.SCAN_CARD_TABLE);
+            } else {
+                walkDirtyObjects(aChunk, visitor, clean);
+            }
             aChunk = HeapChunk.getNext(aChunk);
         }
 
         UnalignedHeader uChunk = space.getFirstUnalignedHeapChunk();
         while (uChunk.isNonNull()) {
-            walkDirtyObjects(uChunk, visitor, clean);
+            if (ParallelGC.isEnabled()) {
+                ParallelGC.singleton().push(uChunk, ParallelGC.SCAN_CARD_TABLE);
+            } else {
+                walkDirtyObjects(uChunk, visitor, clean);
+            }
             uChunk = HeapChunk.getNext(uChunk);
         }
     }
diff --git a/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/remset/FirstObjectTable.java b/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/remset/FirstObjectTable.java
index 2c5f3ff3b14..6c927f47cf0 100644
--- a/graal/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/remset/FirstObjectTable.java
+++ b/graal/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/remset/FirstObjectTable.java
@@ -30,6 +30,7 @@ import org.graalvm.word.WordFactory;
 
 import com.oracle.svm.core.AlwaysInline;
 import com.oracle.svm.core.SubstrateUtil;
+import com.oracle.svm.core.Uninterruptible;
 import com.oracle.svm.core.UnmanagedMemoryUtil;
 import com.oracle.svm.core.config.ConfigurationValues;
 import com.oracle.svm.core.hub.LayoutEncoding;
@@ -163,6 +164,7 @@ final class FirstObjectTable {
     private FirstObjectTable() {
     }
 
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     public static void initializeTable(Pointer table, UnsignedWord size) {
         if (SubstrateUtil.HOSTED) {
             // Initialize this table unconditionally as this simplifies a few things.
@@ -173,12 +175,14 @@ final class FirstObjectTable {
         }
     }
 
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     private static boolean doInitializeTable(Pointer table, UnsignedWord size) {
         UnmanagedMemoryUtil.fill(table, size, (byte) UNINITIALIZED_ENTRY);
         return true;
     }
 
     @AlwaysInline("GC performance")
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     public static void setTableForObject(Pointer table, UnsignedWord startOffset, UnsignedWord endOffset) {
         assert startOffset.belowThan(endOffset);
         UnsignedWord startIndex = memoryOffsetToIndex(startOffset);
@@ -232,6 +236,7 @@ final class FirstObjectTable {
      * outside the current card.
      */
     @AlwaysInline("GC performance")
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     public static Pointer getFirstObjectImprecise(Pointer tableStart, Pointer objectsStart, UnsignedWord index) {
         Pointer result;
         Pointer firstObject = getFirstObject(tableStart, objectsStart, index);
@@ -249,6 +254,7 @@ final class FirstObjectTable {
     }
 
     @AlwaysInline("GC performance")
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     private static Pointer getFirstObject(Pointer tableStart, Pointer objectsStart, UnsignedWord index) {
         UnsignedWord currentIndex = index;
         int currentEntry = getEntryAtIndex(tableStart, currentIndex);
@@ -278,6 +284,8 @@ final class FirstObjectTable {
         return result;
     }
 
+    @AlwaysInline("GC performance")
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     private static UnsignedWord entryToMemoryOffset(UnsignedWord index, int entry) {
         assert isMemoryOffsetEntry(entry) : "Entry out of bounds.";
         UnsignedWord entryOffset = WordFactory.unsigned(-entry).multiply(memoryOffsetScale());
@@ -328,69 +336,83 @@ final class FirstObjectTable {
      * The multiplier from memory offsets to byte offsets into the previous card. This is the
      * granularity to which I can point to the start of an object.
      */
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     private static int memoryOffsetScale() {
         return ConfigurationValues.getObjectLayout().getAlignment();
     }
 
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     private static int getEntryAtIndex(Pointer table, UnsignedWord index) {
         return table.readByte(indexToTableOffset(index));
     }
 
     /** Set the table entry at a given index. */
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     private static void setEntryAtIndex(Pointer table, UnsignedWord index, int value) {
         assert isValidEntry(value) : "Invalid entry";
         assert isUninitializedIndex(table, index) || getEntryAtIndex(table, index) == value : "Overwriting!";
         table.writeByte(indexToTableOffset(index), (byte) value);
     }
 
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     private static boolean isUninitializedIndex(Pointer table, UnsignedWord index) {
         int entry = getEntryAtIndex(table, index);
         return isUninitializedEntry(entry);
     }
 
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     private static boolean isValidEntry(int entry) {
         return ENTRY_MIN <= entry && entry <= ENTRY_MAX;
     }
 
     /** May only be used for assertions. */
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     private static boolean isUninitializedEntry(int entry) {
         assert isValidEntry(entry) : "Invalid entry";
         return entry == UNINITIALIZED_ENTRY;
     }
 
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     private static boolean isMemoryOffsetEntry(int entry) {
         assert isValidEntry(entry) : "Invalid entry";
         return MEMORY_OFFSET_MIN <= entry && entry <= MEMORY_OFFSET_MAX;
     }
 
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     private static int biasExponent(int exponent) {
         assert EXPONENT_MIN <= exponent && exponent <= EXPONENT_MAX : "Exponent out of bounds.";
         return exponent + EXPONENT_BIAS;
     }
 
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     private static int unbiasExponent(int entry) {
         int exponent = entry - EXPONENT_BIAS;
         assert EXPONENT_MIN <= exponent && exponent <= EXPONENT_MAX : "Exponent out of bounds.";
         return exponent;
     }
 
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     private static UnsignedWord exponentToOffset(int n) {
         assert 0 <= n && n <= 63 : "Exponent out of bounds.";
         return WordFactory.unsigned(1L << n);
     }
 
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     private static UnsignedWord indexToTableOffset(UnsignedWord index) {
         return index.multiply(ENTRY_SIZE_BYTES);
     }
 
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     private static UnsignedWord indexToMemoryOffset(UnsignedWord index) {
         return index.multiply(BYTES_COVERED_BY_ENTRY);
     }
 
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     private static UnsignedWord memoryOffsetToIndex(UnsignedWord offset) {
         return offset.unsignedDivide(BYTES_COVERED_BY_ENTRY);
     }
 
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     private static int memoryOffsetToEntry(UnsignedWord memoryOffset) {
         assert memoryOffset.belowThan(BYTES_COVERED_BY_ENTRY) : "Offset out of bounds.";
         UnsignedWord scaledOffset = memoryOffset.unsignedDivide(memoryOffsetScale());
diff --git a/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/remset/NoRememberedSet.java b/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/remset/NoRememberedSet.java
index 8fec4384578..0e9e9868d43 100644
--- a/graal/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/remset/NoRememberedSet.java
+++ b/graal/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/remset/NoRememberedSet.java
@@ -34,6 +34,7 @@ import org.graalvm.word.UnsignedWord;
 import org.graalvm.word.WordFactory;
 
 import com.oracle.svm.core.AlwaysInline;
+import com.oracle.svm.core.Uninterruptible;
 import com.oracle.svm.core.config.ConfigurationValues;
 import com.oracle.svm.core.genscavenge.AlignedHeapChunk.AlignedHeader;
 import com.oracle.svm.core.genscavenge.GreyToBlackObjectVisitor;
@@ -85,32 +86,39 @@ public final class NoRememberedSet implements RememberedSet {
     }
 
     @Override
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     public void enableRememberedSetForChunk(AlignedHeader chunk) {
         // Nothing to do.
     }
 
     @Override
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     public void enableRememberedSetForChunk(UnalignedHeader chunk) {
         // Nothing to do.
     }
 
     @Override
+    @AlwaysInline("GC performance")
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     public void enableRememberedSetForObject(AlignedHeader chunk, Object obj) {
         // Nothing to do.
     }
 
     @Override
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     public void clearRememberedSet(AlignedHeader chunk) {
         // Nothing to do.
     }
 
     @Override
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     public void clearRememberedSet(UnalignedHeader chunk) {
         // Nothing to do.
     }
 
     @Override
     @AlwaysInline("GC performance")
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     public boolean hasRememberedSet(UnsignedWord header) {
         return false;
     }
@@ -127,21 +135,25 @@ public final class NoRememberedSet implements RememberedSet {
 
     @Override
     @AlwaysInline("GC performance")
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     public void dirtyCardIfNecessary(Object holderObject, Object object) {
         // Nothing to do.
     }
 
     @Override
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     public void walkDirtyObjects(AlignedHeader chunk, GreyToBlackObjectVisitor visitor, boolean clean) {
         throw VMError.shouldNotReachHere();
     }
 
     @Override
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     public void walkDirtyObjects(UnalignedHeader chunk, GreyToBlackObjectVisitor visitor, boolean clean) {
         throw VMError.shouldNotReachHere();
     }
 
     @Override
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     public void walkDirtyObjects(Space space, GreyToBlackObjectVisitor visitor, boolean clean) {
         throw VMError.shouldNotReachHere();
     }
diff --git a/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/remset/RememberedSet.java b/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/remset/RememberedSet.java
index d6b1725a296..d641f6569a8 100644
--- a/graal/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/remset/RememberedSet.java
+++ b/graal/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/remset/RememberedSet.java
@@ -33,6 +33,7 @@ import org.graalvm.nativeimage.Platforms;
 import org.graalvm.word.UnsignedWord;
 
 import com.oracle.svm.core.AlwaysInline;
+import com.oracle.svm.core.Uninterruptible;
 import com.oracle.svm.core.genscavenge.AlignedHeapChunk.AlignedHeader;
 import com.oracle.svm.core.genscavenge.GreyToBlackObjectVisitor;
 import com.oracle.svm.core.genscavenge.Space;
@@ -76,28 +77,35 @@ public interface RememberedSet extends BarrierSetProvider {
      * Enables remembered set tracking for an aligned chunk and its objects. Must be called when
      * adding a new chunk to the image heap or old generation.
      */
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     void enableRememberedSetForChunk(AlignedHeader chunk);
 
     /**
      * Enables remembered set tracking for an unaligned chunk and its objects. Must be called when
      * adding a new chunk to the image heap or old generation.
      */
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     void enableRememberedSetForChunk(UnalignedHeader chunk);
 
     /**
      * Enables remembered set tracking for a single object in an aligned chunk. Must be called when
      * an object is added to the image heap or old generation.
      */
+    @AlwaysInline("GC performance")
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     void enableRememberedSetForObject(AlignedHeader chunk, Object obj);
 
     /** Clears the remembered set of an aligned chunk. */
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     void clearRememberedSet(AlignedHeader chunk);
 
     /** Clears the remembered set of an unaligned chunk. */
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     void clearRememberedSet(UnalignedHeader chunk);
 
     /** Checks if remembered set tracking is enabled for an object. */
     @AlwaysInline("GC performance")
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     boolean hasRememberedSet(UnsignedWord header);
 
     /**
@@ -122,21 +130,25 @@ public interface RememberedSet extends BarrierSetProvider {
      * tracking is enabled.
      */
     @AlwaysInline("GC performance")
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     void dirtyCardIfNecessary(Object holderObject, Object object);
 
     /**
      * Walks all dirty objects in an aligned chunk.
      */
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     void walkDirtyObjects(AlignedHeader chunk, GreyToBlackObjectVisitor visitor, boolean clean);
 
     /**
      * Walks all dirty objects in an unaligned chunk.
      */
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     void walkDirtyObjects(UnalignedHeader chunk, GreyToBlackObjectVisitor visitor, boolean clean);
 
     /**
      * Walks all dirty objects in a {@link Space}.
      */
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     void walkDirtyObjects(Space space, GreyToBlackObjectVisitor visitor, boolean clean);
 
     /**
diff --git a/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/remset/UnalignedChunkRememberedSet.java b/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/remset/UnalignedChunkRememberedSet.java
index 1e993fb3f30..c59c995c714 100644
--- a/graal/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/remset/UnalignedChunkRememberedSet.java
+++ b/graal/substratevm/src/com.oracle.svm.core.genscavenge/src/com/oracle/svm/core/genscavenge/remset/UnalignedChunkRememberedSet.java
@@ -33,6 +33,7 @@ import org.graalvm.word.Pointer;
 import org.graalvm.word.UnsignedWord;
 import org.graalvm.word.WordFactory;
 
+import com.oracle.svm.core.Uninterruptible;
 import com.oracle.svm.core.config.ConfigurationValues;
 import com.oracle.svm.core.genscavenge.GreyToBlackObjectVisitor;
 import com.oracle.svm.core.genscavenge.HeapChunk;
@@ -59,6 +60,7 @@ final class UnalignedChunkRememberedSet {
         // The remembered set bit in the header will be set by the code that writes the objects.
     }
 
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     public static void enableRememberedSet(UnalignedHeader chunk) {
         CardTable.cleanTable(getCardTableStart(chunk), getCardTableSize());
         // Unaligned chunks don't have a first object table.
@@ -67,6 +69,7 @@ final class UnalignedChunkRememberedSet {
         ObjectHeaderImpl.setRememberedSetBit(obj);
     }
 
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     public static void clearRememberedSet(UnalignedHeader chunk) {
         CardTable.cleanTable(getCardTableStart(chunk), getCardTableSize());
     }
@@ -75,6 +78,7 @@ final class UnalignedChunkRememberedSet {
      * Dirty the card corresponding to the given Object. This has to be fast, because it is used by
      * the post-write barrier.
      */
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     public static void dirtyCardForObject(Object obj, boolean verifyOnly) {
         UnalignedHeader chunk = UnalignedHeapChunk.getEnclosingChunk(obj);
         Pointer cardTableStart = getCardTableStart(chunk);
@@ -86,6 +90,7 @@ final class UnalignedChunkRememberedSet {
         }
     }
 
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     public static void walkDirtyObjects(UnalignedHeader chunk, GreyToBlackObjectVisitor visitor, boolean clean) {
         Pointer rememberedSetStart = getCardTableStart(chunk);
         UnsignedWord objectIndex = getObjectIndex();
@@ -132,10 +137,12 @@ final class UnalignedChunkRememberedSet {
         return WordFactory.zero();
     }
 
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     private static Pointer getCardTableStart(UnalignedHeader chunk) {
         return getCardTableStart(HeapChunk.asPointer(chunk));
     }
 
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     private static Pointer getCardTableStart(Pointer chunk) {
         return chunk.add(getCardTableStartOffset());
     }
diff --git a/substratevm/src/com.oracle.svm.core.posix/src/com/oracle/svm/core/posix/PosixSubstrateSigprofHandler.java b/substratevm/src/com.oracle.svm.core.posix/src/com/oracle/svm/core/posix/PosixSubstrateSigprofHandler.java
index 3391acca225..df806a2c5ae 100644
--- a/graal/substratevm/src/com.oracle.svm.core.posix/src/com/oracle/svm/core/posix/PosixSubstrateSigprofHandler.java
+++ b/graal/substratevm/src/com.oracle.svm.core.posix/src/com/oracle/svm/core/posix/PosixSubstrateSigprofHandler.java
@@ -31,18 +31,14 @@ import java.util.List;
 
 import org.graalvm.compiler.options.Option;
 import org.graalvm.nativeimage.ImageSingletons;
-import org.graalvm.nativeimage.IsolateThread;
 import org.graalvm.nativeimage.Platform;
 import org.graalvm.nativeimage.Platforms;
-import org.graalvm.nativeimage.StackValue;
 import org.graalvm.nativeimage.c.function.CEntryPoint;
 import org.graalvm.nativeimage.c.function.CEntryPointLiteral;
 import org.graalvm.nativeimage.c.function.CodePointer;
 import org.graalvm.nativeimage.c.struct.SizeOf;
-import org.graalvm.nativeimage.c.type.VoidPointer;
 import org.graalvm.nativeimage.hosted.Feature;
 import org.graalvm.word.Pointer;
-import org.graalvm.word.UnsignedWord;
 import org.graalvm.word.WordFactory;
 
 import com.oracle.svm.core.IsolateListenerSupport;
@@ -59,7 +55,6 @@ import com.oracle.svm.core.heap.RestrictHeapAccess;
 import com.oracle.svm.core.jfr.JfrFeature;
 import com.oracle.svm.core.jfr.sampler.JfrExecutionSampler;
 import com.oracle.svm.core.option.HostedOptionKey;
-import com.oracle.svm.core.posix.headers.Pthread;
 import com.oracle.svm.core.posix.headers.Signal;
 import com.oracle.svm.core.posix.headers.Time;
 import com.oracle.svm.core.sampler.SubstrateSigprofHandler;
@@ -133,38 +128,6 @@ public class PosixSubstrateSigprofHandler extends SubstrateSigprofHandler {
         updateInterval(0);
     }
 
-    @Override
-    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
-    protected UnsignedWord createNativeThreadLocal() {
-        Pthread.pthread_key_tPointer key = StackValue.get(Pthread.pthread_key_tPointer.class);
-        PosixUtils.checkStatusIs0(Pthread.pthread_key_create(key, WordFactory.nullPointer()), "pthread_key_create(key, keyDestructor): failed.");
-        return key.read();
-    }
-
-    @Override
-    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
-    protected void deleteNativeThreadLocal(UnsignedWord key) {
-        int resultCode = Pthread.pthread_key_delete((Pthread.pthread_key_t) key);
-        PosixUtils.checkStatusIs0(resultCode, "pthread_key_delete(key): failed.");
-    }
-
-    @Override
-    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
-    protected void setNativeThreadLocalValue(UnsignedWord key, IsolateThread value) {
-        int resultCode = Pthread.pthread_setspecific((Pthread.pthread_key_t) key, (VoidPointer) value);
-        PosixUtils.checkStatusIs0(resultCode, "pthread_setspecific(key, value): wrong arguments.");
-    }
-
-    @Override
-    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
-    protected IsolateThread getNativeThreadLocalValue(UnsignedWord key) {
-        /*
-         * Although this method is not async-signal-safe in general we rely on
-         * implementation-specific behavior here.
-         */
-        return (IsolateThread) Pthread.pthread_getspecific((Pthread.pthread_key_t) key);
-    }
-
     public static class Options {
         @Option(help = "Determines if JFR uses a signal handler for execution sampling.")//
         public static final HostedOptionKey<Boolean> SignalHandlerBasedExecutionSampler = new HostedOptionKey<>(false);
diff --git a/substratevm/src/com.oracle.svm.core.posix/src/com/oracle/svm/core/posix/pthread/PthreadVMLockSupport.java b/substratevm/src/com.oracle.svm.core.posix/src/com/oracle/svm/core/posix/pthread/PthreadVMLockSupport.java
index 0920dc919b2..018858da267 100644
--- a/graal/substratevm/src/com.oracle.svm.core.posix/src/com/oracle/svm/core/posix/pthread/PthreadVMLockSupport.java
+++ b/graal/substratevm/src/com.oracle.svm.core.posix/src/com/oracle/svm/core/posix/pthread/PthreadVMLockSupport.java
@@ -371,6 +371,7 @@ final class PthreadVMCondition extends VMCondition {
     }
 
     @Override
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     public void signal() {
         PthreadVMLockSupport.checkResult(Pthread.pthread_cond_signal(getStructPointer()), "pthread_cond_signal");
     }
diff --git a/substratevm/src/com.oracle.svm.core.posix/src/com/oracle/svm/core/posix/thread/PosixPlatformThreads.java b/substratevm/src/com.oracle.svm.core.posix/src/com/oracle/svm/core/posix/thread/PosixPlatformThreads.java
index de01408eecb..954b25735bd 100644
--- a/graal/substratevm/src/com.oracle.svm.core.posix/src/com/oracle/svm/core/posix/thread/PosixPlatformThreads.java
+++ b/graal/substratevm/src/com.oracle.svm.core.posix/src/com/oracle/svm/core/posix/thread/PosixPlatformThreads.java
@@ -34,11 +34,13 @@ import org.graalvm.nativeimage.c.function.CFunctionPointer;
 import org.graalvm.nativeimage.c.struct.SizeOf;
 import org.graalvm.nativeimage.c.type.CTypeConversion;
 import org.graalvm.nativeimage.c.type.CTypeConversion.CCharPointerHolder;
+import org.graalvm.nativeimage.c.type.VoidPointer;
 import org.graalvm.nativeimage.c.type.WordPointer;
 import org.graalvm.nativeimage.impl.UnmanagedMemorySupport;
 import org.graalvm.word.Pointer;
 import org.graalvm.word.PointerBase;
 import org.graalvm.word.UnsignedWord;
+import org.graalvm.word.WordBase;
 import org.graalvm.word.WordFactory;
 
 import com.oracle.svm.core.NeverInline;
@@ -65,6 +67,7 @@ import com.oracle.svm.core.stack.StackOverflowCheck;
 import com.oracle.svm.core.thread.Parker;
 import com.oracle.svm.core.thread.Parker.ParkerFactory;
 import com.oracle.svm.core.thread.PlatformThreads;
+import com.oracle.svm.core.thread.PlatformThreads.ThreadLocalKey;
 import com.oracle.svm.core.thread.VMThreads.OSThreadHandle;
 import com.oracle.svm.core.util.UnsignedUtils;
 import com.oracle.svm.core.util.VMError;
@@ -251,6 +254,39 @@ public final class PosixPlatformThreads extends PlatformThreads {
         int status = Pthread.pthread_join_no_transition((Pthread.pthread_t) threadHandle, threadExitStatus);
         return status == 0;
     }
+
+    @Override
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
+    public ThreadLocalKey createUnmanagedThreadLocal() {
+        Pthread.pthread_key_tPointer key = StackValue.get(Pthread.pthread_key_tPointer.class);
+        PosixUtils.checkStatusIs0(Pthread.pthread_key_create(key, WordFactory.nullPointer()), "pthread_key_create(key, keyDestructor): failed.");
+        return (ThreadLocalKey) key.read();
+    }
+
+    @Override
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
+    public void deleteUnmanagedThreadLocal(ThreadLocalKey key) {
+        int resultCode = Pthread.pthread_key_delete((Pthread.pthread_key_t) key);
+        PosixUtils.checkStatusIs0(resultCode, "pthread_key_delete(key): failed.");
+    }
+
+    @Override
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
+    @SuppressWarnings("unchecked")
+    public <T extends WordBase> T getUnmanagedThreadLocalValue(ThreadLocalKey key) {
+        /*
+         * Although this method is not async-signal-safe in general we rely on
+         * implementation-specific behavior here.
+         */
+        return (T) Pthread.pthread_getspecific((Pthread.pthread_key_t) key);
+    }
+
+    @Override
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
+    public void setUnmanagedThreadLocalValue(ThreadLocalKey key, WordBase value) {
+        int resultCode = Pthread.pthread_setspecific((Pthread.pthread_key_t) key, (VoidPointer) value);
+        PosixUtils.checkStatusIs0(resultCode, "pthread_setspecific(key, value): wrong arguments.");
+    }
 }
 
 @TargetClass(Thread.class)
diff --git a/substratevm/src/com.oracle.svm.core.windows/src/com/oracle/svm/core/windows/WindowsPlatformThreads.java b/substratevm/src/com.oracle.svm.core.windows/src/com/oracle/svm/core/windows/WindowsPlatformThreads.java
index bcea0d4764f..3e5697cea15 100644
--- a/graal/substratevm/src/com.oracle.svm.core.windows/src/com/oracle/svm/core/windows/WindowsPlatformThreads.java
+++ b/graal/substratevm/src/com.oracle.svm.core.windows/src/com/oracle/svm/core/windows/WindowsPlatformThreads.java
@@ -31,8 +31,10 @@ import org.graalvm.nativeimage.Platforms;
 import org.graalvm.nativeimage.c.function.CFunctionPointer;
 import org.graalvm.nativeimage.c.struct.SizeOf;
 import org.graalvm.nativeimage.c.type.CIntPointer;
+import org.graalvm.nativeimage.c.type.VoidPointer;
 import org.graalvm.nativeimage.c.type.WordPointer;
 import org.graalvm.word.PointerBase;
+import org.graalvm.word.WordBase;
 import org.graalvm.word.WordFactory;
 
 import com.oracle.svm.core.Uninterruptible;
@@ -115,14 +117,44 @@ public final class WindowsPlatformThreads extends PlatformThreads {
         }
         // Since only an int is written, first clear word
         threadExitStatus.write(WordFactory.zero());
-        if (Process.NoTransitions.GetExitCodeThread((WinBase.HANDLE) threadHandle, (CIntPointer) threadExitStatus) == 0) {
-            return false;
-        }
-        return true;
+        return Process.NoTransitions.GetExitCodeThread((WinBase.HANDLE) threadHandle, (CIntPointer) threadExitStatus) != 0;
+    }
+
+    @Override
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
+    public ThreadLocalKey createUnmanagedThreadLocal() {
+        int result = Process.NoTransitions.TlsAlloc();
+        VMError.guarantee(result != Process.TLS_OUT_OF_INDEXES(), "TlsAlloc failed.");
+        return WordFactory.unsigned(result);
+    }
+
+    @Override
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
+    public void deleteUnmanagedThreadLocal(ThreadLocalKey key) {
+        int dwTlsIndex = (int) key.rawValue();
+        int result = Process.NoTransitions.TlsFree(dwTlsIndex);
+        VMError.guarantee(result != 0, "TlsFree failed.");
+    }
+
+    @Override
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
+    @SuppressWarnings("unchecked")
+    public <T extends WordBase> T getUnmanagedThreadLocalValue(ThreadLocalKey key) {
+        int dwTlsIndex = (int) key.rawValue();
+        VoidPointer result = Process.NoTransitions.TlsGetValue(dwTlsIndex);
+        assert result.isNonNull() || WinBase.GetLastError() == WinBase.ERROR_SUCCESS();
+        return (T) result;
+    }
+
+    @Override
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
+    public void setUnmanagedThreadLocalValue(ThreadLocalKey key, WordBase value) {
+        int dwTlsIndex = (int) key.rawValue();
+        int result = Process.NoTransitions.TlsSetValue(dwTlsIndex, (VoidPointer) value);
+        VMError.guarantee(result != 0, "TlsSetValue failed.");
     }
 
     @Override
-    @SuppressWarnings("unused")
     @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     public void closeOSThreadHandle(OSThreadHandle threadHandle) {
         WinBase.CloseHandle((WinBase.HANDLE) threadHandle);
diff --git a/substratevm/src/com.oracle.svm.core.windows/src/com/oracle/svm/core/windows/WindowsVMLockSupport.java b/substratevm/src/com.oracle.svm.core.windows/src/com/oracle/svm/core/windows/WindowsVMLockSupport.java
index 26cf5e0af41..879aaed70bd 100644
--- a/graal/substratevm/src/com.oracle.svm.core.windows/src/com/oracle/svm/core/windows/WindowsVMLockSupport.java
+++ b/graal/substratevm/src/com.oracle.svm.core.windows/src/com/oracle/svm/core/windows/WindowsVMLockSupport.java
@@ -359,6 +359,7 @@ final class WindowsVMCondition extends VMCondition {
     }
 
     @Override
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     public void signal() {
         Process.NoTransitions.WakeConditionVariable(getStructPointer());
     }
diff --git a/substratevm/src/com.oracle.svm.core.windows/src/com/oracle/svm/core/windows/headers/Process.java b/substratevm/src/com.oracle.svm.core.windows/src/com/oracle/svm/core/windows/headers/Process.java
index a79858be852..530ecbc96af 100644
--- a/graal/substratevm/src/com.oracle.svm.core.windows/src/com/oracle/svm/core/windows/headers/Process.java
+++ b/graal/substratevm/src/com.oracle.svm.core.windows/src/com/oracle/svm/core/windows/headers/Process.java
@@ -30,6 +30,8 @@ import org.graalvm.nativeimage.c.function.CFunction;
 import org.graalvm.nativeimage.c.function.CFunction.Transition;
 import org.graalvm.nativeimage.c.struct.CStruct;
 import org.graalvm.nativeimage.c.type.CIntPointer;
+import org.graalvm.nativeimage.c.type.CUnsigned;
+import org.graalvm.nativeimage.c.type.VoidPointer;
 import org.graalvm.word.PointerBase;
 import org.graalvm.word.WordBase;
 
@@ -73,6 +75,9 @@ public class Process {
     @CConstant
     public static native int THREAD_QUERY_LIMITED_INFORMATION();
 
+    @CConstant
+    public static native int TLS_OUT_OF_INDEXES();
+
     @CStruct
     public interface PCRITICAL_SECTION extends PointerBase {
     }
@@ -153,5 +158,17 @@ public class Process {
 
         @CFunction(transition = Transition.NO_TRANSITION)
         public static native boolean GetThreadTimes(HANDLE hThread, FILETIME creationTime, FILETIME exitTime, FILETIME kernelTime, FILETIME userTime);
+
+        @CFunction(transition = Transition.NO_TRANSITION)
+        public static native @CUnsigned int TlsAlloc();
+
+        @CFunction(transition = Transition.NO_TRANSITION)
+        public static native int TlsFree(@CUnsigned int dwTlsIndex);
+
+        @CFunction(transition = Transition.NO_TRANSITION)
+        public static native VoidPointer TlsGetValue(@CUnsigned int dwTlsIndex);
+
+        @CFunction(transition = Transition.NO_TRANSITION)
+        public static native int TlsSetValue(@CUnsigned int dwTlsIndex, VoidPointer lpTlsValue);
     }
 }
diff --git a/substratevm/src/com.oracle.svm.core.windows/src/com/oracle/svm/core/windows/headers/WinBase.java b/substratevm/src/com.oracle.svm.core.windows/src/com/oracle/svm/core/windows/headers/WinBase.java
index 0ef4799bf7d..ef654719b05 100644
--- a/graal/substratevm/src/com.oracle.svm.core.windows/src/com/oracle/svm/core/windows/headers/WinBase.java
+++ b/graal/substratevm/src/com.oracle.svm.core.windows/src/com/oracle/svm/core/windows/headers/WinBase.java
@@ -95,6 +95,9 @@ public class WinBase {
     @CConstant
     public static native int ERROR_TIMEOUT();
 
+    @CConstant
+    public static native int ERROR_SUCCESS();
+
     /**
      * QueryPerformance Counter - used for elapsed time
      */
diff --git a/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/MemoryWalker.java b/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/MemoryWalker.java
index a480231284e..980c7db17c4 100644
--- a/graal/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/MemoryWalker.java
+++ b/graal/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/MemoryWalker.java
@@ -27,9 +27,9 @@ package com.oracle.svm.core;
 import org.graalvm.word.PointerBase;
 import org.graalvm.word.UnsignedWord;
 
-import com.oracle.svm.core.heap.RestrictHeapAccess;
 import com.oracle.svm.core.code.CodeInfo;
 import com.oracle.svm.core.heap.ObjectVisitor;
+import com.oracle.svm.core.heap.RestrictHeapAccess;
 
 /** A walker over different kinds of allocated memory. */
 public final class MemoryWalker {
@@ -80,21 +80,6 @@ public final class MemoryWalker {
         /** Return the size of the heap chunk. */
         UnsignedWord getSize(T heapChunk);
 
-        /** Return the address where allocation starts within the heap chunk. */
-        UnsignedWord getAllocationStart(T heapChunk);
-
-        /**
-         * Return the address where allocation has ended within the heap chunk. This is the first
-         * address past the end of allocated space within the heap chunk.
-         */
-        UnsignedWord getAllocationEnd(T heapChunk);
-
-        /**
-         * Return the name of the region that contains the heap chunk. E.g., "young", "old", "free",
-         * etc.
-         */
-        String getRegion(T heapChunk);
-
         /** Return true if the heap chunk is an aligned heap chunk, else false. */
         boolean isAligned(T heapChunk);
     }
diff --git a/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/SubstrateDiagnostics.java b/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/SubstrateDiagnostics.java
index 1f6ee7bf506..0056782de02 100644
--- a/graal/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/SubstrateDiagnostics.java
+++ b/graal/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/SubstrateDiagnostics.java
@@ -132,7 +132,7 @@ public class SubstrateDiagnostics {
 
     @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     public static boolean isFatalErrorHandlingThread() {
-        return fatalErrorState().diagnosticThread.get() == CurrentIsolate.getCurrentThread();
+        return CurrentIsolate.getCurrentThread().isNonNull() && fatalErrorState().diagnosticThread.get() == CurrentIsolate.getCurrentThread();
     }
 
     public static int maxInvocations() {
diff --git a/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/SubstrateOptions.java b/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/SubstrateOptions.java
index 71cbf24a3e0..c779b431837 100644
--- a/graal/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/SubstrateOptions.java
+++ b/graal/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/SubstrateOptions.java
@@ -65,6 +65,7 @@ import com.oracle.svm.core.option.LocatableMultiOptionValue;
 import com.oracle.svm.core.option.RuntimeOptionKey;
 import com.oracle.svm.core.option.SubstrateOptionsParser;
 import com.oracle.svm.core.thread.VMOperationControl;
+import com.oracle.svm.core.util.InterruptImageBuilding;
 import com.oracle.svm.core.util.UserError;
 import com.oracle.svm.util.ModuleSupport;
 import com.oracle.svm.util.ReflectionUtil;
@@ -295,6 +296,7 @@ public class SubstrateOptions {
         @Override
         protected void onValueUpdate(EconomicMap<OptionKey<?>, Object> values, Boolean oldValue, Boolean newValue) {
             if (newValue) {
+                SubstrateOptions.UseParallelGC.update(values, false);
                 SubstrateOptions.UseEpsilonGC.update(values, false);
             }
         }
@@ -307,9 +309,44 @@ public class SubstrateOptions {
         protected void onValueUpdate(EconomicMap<OptionKey<?>, Object> values, Boolean oldValue, Boolean newValue) {
             if (newValue) {
                 SubstrateOptions.UseSerialGC.update(values, false);
+                SubstrateOptions.UseParallelGC.update(values, false);
             }
         }
     };
+
+    @APIOption(name = "parallel", group = GCGroup.class, customHelp = "Parallel garbage collector")//
+    @Option(help = "Use a parallel GC")//
+    public static final HostedOptionKey<Boolean> UseParallelGC = new HostedOptionKey<>(false, SubstrateOptions::requireMultiThreading) {
+        @Override
+        protected void onValueUpdate(EconomicMap<OptionKey<?>, Object> values, Boolean oldValue, Boolean newValue) {
+            if (newValue) {
+                SubstrateOptions.UseSerialGC.update(values, false);
+                SubstrateOptions.UseEpsilonGC.update(values, false);
+            }
+        }
+    };
+
+    @Option(help = "Number of GC worker threads. Parallel and G1 GC only.", type = OptionType.User)//
+    public static final RuntimeOptionKey<Integer> ParallelGCThreads = new RuntimeOptionKey<>(0, Immutable);
+
+    private static void requireMultiThreading(HostedOptionKey<Boolean> optionKey) {
+        if (optionKey.getValue() && !MultiThreaded.getValue()) {
+            throw new InterruptImageBuilding(String.format("The option %s requires the option %s to be set.",
+                            SubstrateOptionsParser.commandArgument(optionKey, "+"),
+                            SubstrateOptionsParser.commandArgument(MultiThreaded, "+")));
+        }
+    }
+
+    @Fold
+    public static boolean useSerialOrParallelGC() {
+        return UseSerialGC.getValue() || UseParallelGC.getValue();
+    }
+
+    @Fold
+    public static boolean useSerialOrParallelOrEpsilonGC() {
+        return UseSerialGC.getValue() || UseParallelGC.getValue() || UseEpsilonGC.getValue();
+    }
+
     @Option(help = "Physical memory size (in bytes). By default, the value is queried from the OS/container during VM startup.", type = OptionType.Expert)//
     public static final RuntimeOptionKey<Long> MaxRAM = new RuntimeOptionKey<>(0L, Immutable);
 
diff --git a/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/c/NonmovableArrays.java b/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/c/NonmovableArrays.java
index cb8b929c1db..a63a9c01afc 100644
--- a/graal/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/c/NonmovableArrays.java
+++ b/graal/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/c/NonmovableArrays.java
@@ -43,8 +43,8 @@ import org.graalvm.word.WordFactory;
 
 import com.oracle.svm.core.JavaMemoryUtil;
 import com.oracle.svm.core.SubstrateUtil;
-import com.oracle.svm.core.UnmanagedMemoryUtil;
 import com.oracle.svm.core.Uninterruptible;
+import com.oracle.svm.core.UnmanagedMemoryUtil;
 import com.oracle.svm.core.config.ConfigurationValues;
 import com.oracle.svm.core.heap.Heap;
 import com.oracle.svm.core.heap.ObjectHeader;
@@ -443,6 +443,7 @@ public final class NonmovableArrays {
     /**
      * Visits all array elements with the provided {@link ObjectReferenceVisitor}.
      */
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     public static boolean walkUnmanagedObjectArray(NonmovableObjectArray<?> array, ObjectReferenceVisitor visitor) {
         if (array.isNonNull()) {
             return walkUnmanagedObjectArray(array, visitor, 0, lengthOf(array));
@@ -453,6 +454,7 @@ public final class NonmovableArrays {
     /**
      * Visits all array elements with the provided {@link ObjectReferenceVisitor}.
      */
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     public static boolean walkUnmanagedObjectArray(NonmovableObjectArray<?> array, ObjectReferenceVisitor visitor, int startIndex, int count) {
         if (array.isNonNull()) {
             assert startIndex >= 0 && count <= lengthOf(array) - startIndex;
@@ -460,7 +462,7 @@ public final class NonmovableArrays {
             assert refSize == (1 << readElementShift(array));
             Pointer p = ((Pointer) array).add(readArrayBase(array)).add(startIndex * refSize);
             for (int i = 0; i < count; i++) {
-                if (!visitor.visitObjectReference(p, true, null)) {
+                if (!callVisitor(visitor, p)) {
                     return false;
                 }
                 p = p.add(refSize);
@@ -469,6 +471,11 @@ public final class NonmovableArrays {
         return true;
     }
 
+    @Uninterruptible(reason = "Bridge between uninterruptible and potentially interruptible code.", mayBeInlined = true, calleeMustBe = false)
+    private static boolean callVisitor(ObjectReferenceVisitor visitor, Pointer p) {
+        return visitor.visitObjectReference(p, true, null);
+    }
+
     @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     public static void tearDown() {
         assert runtimeArraysInExistence.get() == 0 : "All runtime-allocated NonmovableArrays must have been freed";
diff --git a/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/code/CodeInfoTable.java b/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/code/CodeInfoTable.java
index ffdddf3856d..1ce82946f0c 100644
--- a/graal/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/code/CodeInfoTable.java
+++ b/graal/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/code/CodeInfoTable.java
@@ -152,6 +152,7 @@ public class CodeInfoTable {
         return CodeReferenceMapDecoder.walkOffsetsFromPointer(sp, referenceMapEncoding, referenceMapIndex, visitor, null);
     }
 
+    @Uninterruptible(reason = "Not really uninterruptible, but we are about to fail.", calleeMustBe = false)
     public static RuntimeException reportNoReferenceMap(Pointer sp, CodePointer ip, CodeInfo info) {
         Log.log().string("ip: ").hex(ip).string("  sp: ").hex(sp).string("  info:");
         CodeInfoAccess.log(info, Log.log()).newline();
diff --git a/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/code/RuntimeCodeInfoAccess.java b/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/code/RuntimeCodeInfoAccess.java
index bc73558502e..32a50c728d7 100644
--- a/graal/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/code/RuntimeCodeInfoAccess.java
+++ b/graal/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/code/RuntimeCodeInfoAccess.java
@@ -151,6 +151,7 @@ public final class RuntimeCodeInfoAccess {
     /**
      * Walks all strong references in a {@link CodeInfo} object.
      */
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     public static boolean walkStrongReferences(CodeInfo info, ObjectReferenceVisitor visitor) {
         return NonmovableArrays.walkUnmanagedObjectArray(cast(info).getObjectFields(), visitor, CodeInfoImpl.FIRST_STRONGLY_REFERENCED_OBJFIELD, CodeInfoImpl.STRONGLY_REFERENCED_OBJFIELD_COUNT);
     }
@@ -159,6 +160,7 @@ public final class RuntimeCodeInfoAccess {
      * Walks all weak references in a {@link CodeInfo} object.
      */
     @DuplicatedInNativeCode
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     public static boolean walkWeakReferences(CodeInfo info, ObjectReferenceVisitor visitor) {
         CodeInfoImpl impl = cast(info);
         boolean continueVisiting = true;
diff --git a/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/code/RuntimeCodeInfoMemory.java b/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/code/RuntimeCodeInfoMemory.java
index a2bc227f563..cdb27e1dbc5 100644
--- a/graal/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/code/RuntimeCodeInfoMemory.java
+++ b/graal/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/code/RuntimeCodeInfoMemory.java
@@ -201,14 +201,16 @@ public class RuntimeCodeInfoMemory {
         }
     }
 
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     public void walkRuntimeMethodsDuringGC(CodeInfoVisitor visitor) {
         assert VMOperation.isGCInProgress() : "otherwise, we would need to make sure that the CodeInfo is not freeded by the GC";
         if (table.isNonNull()) {
             int length = NonmovableArrays.lengthOf(table);
             for (int i = 0; i < length;) {
-                UntetheredCodeInfo info = NonmovableArrays.getWord(table, i);
-                if (info.isNonNull()) {
-                    visitor.visitCode(CodeInfoAccess.convert(info));
+                UntetheredCodeInfo untetheredInfo = NonmovableArrays.getWord(table, i);
+                if (untetheredInfo.isNonNull()) {
+                    CodeInfo info = CodeInfoAccess.convert(untetheredInfo);
+                    callVisitor(visitor, info);
                 }
 
                 /*
@@ -216,7 +218,7 @@ public class RuntimeCodeInfoMemory {
                  * visit the now updated entry one more time. However, this could have the effect
                  * that some entries are visited more than once.
                  */
-                if (info == NonmovableArrays.getWord(table, i)) {
+                if (untetheredInfo == NonmovableArrays.getWord(table, i)) {
                     i++;
                 }
             }
@@ -228,23 +230,24 @@ public class RuntimeCodeInfoMemory {
         if (table.isNonNull()) {
             int length = NonmovableArrays.lengthOf(table);
             for (int i = 0; i < length; i++) {
-                UntetheredCodeInfo info = NonmovableArrays.getWord(table, i);
-                if (info.isNonNull()) {
-                    Object tether = CodeInfoAccess.acquireTether(info);
+                UntetheredCodeInfo untetheredInfo = NonmovableArrays.getWord(table, i);
+                if (untetheredInfo.isNonNull()) {
+                    Object tether = CodeInfoAccess.acquireTether(untetheredInfo);
                     try {
-                        callVisitor(visitor, info, tether);
+                        CodeInfo info = CodeInfoAccess.convert(untetheredInfo, tether);
+                        callVisitor(visitor, info);
                     } finally {
-                        CodeInfoAccess.releaseTether(info, tether);
+                        CodeInfoAccess.releaseTether(untetheredInfo, tether);
                     }
-                    assert info == NonmovableArrays.getWord(table, i);
+                    assert untetheredInfo == NonmovableArrays.getWord(table, i);
                 }
             }
         }
     }
 
-    @Uninterruptible(reason = "Call the visitor, which may execute interruptible code.", calleeMustBe = false)
-    private static void callVisitor(CodeInfoVisitor visitor, UntetheredCodeInfo info, Object tether) {
-        visitor.visitCode(CodeInfoAccess.convert(info, tether));
+    @Uninterruptible(reason = "Bridge between uninterruptible and potentially interruptible code.", mayBeInlined = true, calleeMustBe = false)
+    private static void callVisitor(CodeInfoVisitor visitor, CodeInfo info) {
+        visitor.visitCode(info);
     }
 
     @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
diff --git a/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/config/ObjectLayout.java b/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/config/ObjectLayout.java
index 61d9aca4aea..407667a45ab 100644
--- a/graal/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/config/ObjectLayout.java
+++ b/graal/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/config/ObjectLayout.java
@@ -76,11 +76,13 @@ public final class ObjectLayout {
     }
 
     /** The minimum alignment of objects (instances and arrays). */
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     public int getAlignment() {
         return objectAlignment;
     }
 
     /** Tests if the given offset or address is aligned according to {@link #getAlignment()}. */
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     public boolean isAligned(final long value) {
         return (value % getAlignment() == 0L);
     }
diff --git a/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/heap/CodeReferenceMapDecoder.java b/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/heap/CodeReferenceMapDecoder.java
index a85773cdd5e..6eba6c4dfc5 100644
--- a/graal/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/heap/CodeReferenceMapDecoder.java
+++ b/graal/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/heap/CodeReferenceMapDecoder.java
@@ -186,7 +186,7 @@ public class CodeReferenceMapDecoder {
     }
 
     @AlwaysInline("de-virtualize calls to ObjectReferenceVisitor")
-    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true, calleeMustBe = false)
+    @Uninterruptible(reason = "Bridge between uninterruptible and potentially interruptible code.", mayBeInlined = true, calleeMustBe = false)
     private static boolean callVisitObjectReferenceInline(ObjectReferenceVisitor visitor, Pointer derivedRef, int innerOffset, boolean compressed, Object holderObject) {
         return visitor.visitObjectReferenceInline(derivedRef, innerOffset, compressed, holderObject);
     }
diff --git a/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/heap/InstanceReferenceMapDecoder.java b/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/heap/InstanceReferenceMapDecoder.java
index c203d92c0fe..447d6fc34e7 100644
--- a/graal/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/heap/InstanceReferenceMapDecoder.java
+++ b/graal/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/heap/InstanceReferenceMapDecoder.java
@@ -29,15 +29,17 @@ import org.graalvm.word.UnsignedWord;
 import org.graalvm.word.WordFactory;
 
 import com.oracle.svm.core.AlwaysInline;
-import com.oracle.svm.core.util.DuplicatedInNativeCode;
+import com.oracle.svm.core.Uninterruptible;
 import com.oracle.svm.core.c.NonmovableArray;
 import com.oracle.svm.core.config.ConfigurationValues;
+import com.oracle.svm.core.util.DuplicatedInNativeCode;
 import com.oracle.svm.core.util.NonmovableByteArrayReader;
 import com.oracle.svm.core.util.TypedMemoryReader;
 
 @DuplicatedInNativeCode
 public class InstanceReferenceMapDecoder {
     @AlwaysInline("de-virtualize calls to ObjectReferenceVisitor")
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     public static boolean walkOffsetsFromPointer(Pointer baseAddress, NonmovableArray<Byte> referenceMapEncoding, long referenceMapIndex, ObjectReferenceVisitor visitor, Object holderObject) {
         assert ReferenceMapIndex.denotesValidReferenceMap(referenceMapIndex);
         assert referenceMapEncoding.isNonNull();
@@ -61,7 +63,7 @@ public class InstanceReferenceMapDecoder {
 
             Pointer objRef = baseAddress.add(offset);
             for (int c = 0; c < count; c++) {
-                final boolean visitResult = visitor.visitObjectReferenceInline(objRef, 0, compressed, holderObject);
+                final boolean visitResult = callVisitor(visitor, holderObject, compressed, objRef);
                 if (!visitResult) {
                     return false;
                 }
@@ -70,4 +72,9 @@ public class InstanceReferenceMapDecoder {
         }
         return true;
     }
+
+    @Uninterruptible(reason = "Bridge between uninterruptible and potentially interruptible code.", mayBeInlined = true, calleeMustBe = false)
+    private static boolean callVisitor(ObjectReferenceVisitor visitor, Object holderObject, boolean compressed, Pointer objRef) {
+        return visitor.visitObjectReferenceInline(objRef, 0, compressed, holderObject);
+    }
 }
diff --git a/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/heap/ObjectHeader.java b/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/heap/ObjectHeader.java
index f6b0edb0da0..257578b8da5 100644
--- a/graal/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/heap/ObjectHeader.java
+++ b/graal/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/heap/ObjectHeader.java
@@ -62,6 +62,7 @@ public abstract class ObjectHeader {
     @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     public abstract DynamicHub dynamicHubFromObjectHeader(Word header);
 
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     public static DynamicHub readDynamicHubFromObject(Object o) {
         return KnownIntrinsics.readHub(o);
     }
diff --git a/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/heap/ObjectVisitor.java b/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/heap/ObjectVisitor.java
index ac706669506..7882d214733 100644
--- a/graal/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/heap/ObjectVisitor.java
+++ b/graal/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/heap/ObjectVisitor.java
@@ -38,7 +38,9 @@ public interface ObjectVisitor {
     @RestrictHeapAccess(access = RestrictHeapAccess.Access.NO_ALLOCATION, reason = "Must not allocate while visiting the heap.")
     boolean visitObject(Object o);
 
-    /** Like visitObject(Object), but inlined for performance. */
+    /**
+     * Like visitObject(Object), but inlined for performance.
+     */
     @RestrictHeapAccess(access = RestrictHeapAccess.Access.NO_ALLOCATION, reason = "Must not allocate while visiting the heap.")
     default boolean visitObjectInline(Object o) {
         return visitObject(o);
diff --git a/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/heap/OutOfMemoryUtil.java b/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/heap/OutOfMemoryUtil.java
index 579c8e015d8..7417cafec9e 100644
--- a/graal/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/heap/OutOfMemoryUtil.java
+++ b/graal/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/heap/OutOfMemoryUtil.java
@@ -25,9 +25,11 @@
 package com.oracle.svm.core.heap;
 
 import com.oracle.svm.core.SubstrateGCOptions;
+import com.oracle.svm.core.Uninterruptible;
 import com.oracle.svm.core.headers.LibC;
 import com.oracle.svm.core.jdk.JDKUtils;
 import com.oracle.svm.core.log.Log;
+import com.oracle.svm.core.thread.VMOperation;
 import com.oracle.svm.core.util.VMError;
 
 /**
@@ -43,8 +45,18 @@ public class OutOfMemoryUtil {
         return reportOutOfMemoryError(OUT_OF_MEMORY_ERROR);
     }
 
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     @RestrictHeapAccess(access = RestrictHeapAccess.Access.NO_ALLOCATION, reason = "Can't allocate while out of memory.")
     public static OutOfMemoryError reportOutOfMemoryError(OutOfMemoryError error) {
+        if (VMOperation.isGCInProgress()) {
+            /* An OutOfMemoryError during a GC is always a fatal error. */
+            throw VMError.shouldNotReachHere(error);
+        }
+        throw reportOutOfMemoryError0(error);
+    }
+
+    @Uninterruptible(reason = "Not uninterruptible but it doesn't matter for the callers.", calleeMustBe = false)
+    private static OutOfMemoryError reportOutOfMemoryError0(OutOfMemoryError error) {
         if (SubstrateGCOptions.ExitOnOutOfMemoryError.getValue()) {
             if (LibC.isSupported()) {
                 Log.log().string("Terminating due to java.lang.OutOfMemoryError: ").string(JDKUtils.getRawMessage(error)).newline();
diff --git a/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/heap/PodReferenceMapDecoder.java b/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/heap/PodReferenceMapDecoder.java
index bd10eb301a5..913455f9615 100644
--- a/graal/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/heap/PodReferenceMapDecoder.java
+++ b/graal/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/heap/PodReferenceMapDecoder.java
@@ -34,16 +34,19 @@ import org.graalvm.word.WordFactory;
 
 import com.oracle.svm.core.AlwaysInline;
 import com.oracle.svm.core.JavaMemoryUtil;
+import com.oracle.svm.core.Uninterruptible;
 import com.oracle.svm.core.config.ConfigurationValues;
 import com.oracle.svm.core.graal.nodes.NewPodInstanceNode;
 import com.oracle.svm.core.hub.DynamicHub;
 import com.oracle.svm.core.hub.LayoutEncoding;
+import com.oracle.svm.core.jdk.UninterruptibleUtils;
 import com.oracle.svm.core.util.DuplicatedInNativeCode;
 import com.oracle.svm.core.util.UnsignedUtils;
 
 public final class PodReferenceMapDecoder {
     @DuplicatedInNativeCode
     @AlwaysInline("de-virtualize calls to ObjectReferenceVisitor")
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     public static boolean walkOffsetsFromPointer(Pointer baseAddress, int layoutEncoding, ObjectReferenceVisitor visitor, Object obj) {
         int referenceSize = ConfigurationValues.getObjectLayout().getReferenceSize();
         boolean isCompressed = ReferenceAccess.singleton().haveCompressedReferences();
@@ -55,11 +58,11 @@ public final class PodReferenceMapDecoder {
         int gap;
         do {
             mapOffset = mapOffset.subtract(2);
-            gap = Byte.toUnsignedInt(baseAddress.readByte(mapOffset));
-            nrefs = Byte.toUnsignedInt(baseAddress.readByte(mapOffset.add(1)));
+            gap = UninterruptibleUtils.Byte.toUnsignedInt(baseAddress.readByte(mapOffset));
+            nrefs = UninterruptibleUtils.Byte.toUnsignedInt(baseAddress.readByte(mapOffset.add(1)));
 
             for (int i = 0; i < nrefs; i++) {
-                if (!visitor.visitObjectReferenceInline(baseAddress.add(refOffset), 0, isCompressed, obj)) {
+                if (!callVisitor(baseAddress, visitor, obj, isCompressed, refOffset)) {
                     return false;
                 }
                 refOffset = refOffset.add(referenceSize);
@@ -70,6 +73,11 @@ public final class PodReferenceMapDecoder {
         return true;
     }
 
+    @Uninterruptible(reason = "Bridge between uninterruptible and potentially interruptible code.", mayBeInlined = true, calleeMustBe = false)
+    private static boolean callVisitor(Pointer baseAddress, ObjectReferenceVisitor visitor, Object obj, boolean isCompressed, UnsignedWord refOffset) {
+        return visitor.visitObjectReferenceInline(baseAddress.add(refOffset), 0, isCompressed, obj);
+    }
+
     /**
      * Implements the allocation and the copying of the reference map and data stored in the hybrid
      * array for {@link Object#clone()}.
diff --git a/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/heap/ReferenceInternals.java b/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/heap/ReferenceInternals.java
index 68605e09b18..f0c879cd838 100644
--- a/graal/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/heap/ReferenceInternals.java
+++ b/graal/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/heap/ReferenceInternals.java
@@ -69,6 +69,7 @@ public final class ReferenceInternals {
     }
 
     /** Barrier-less read of {@link Target_java_lang_ref_Reference#referent} as a pointer. */
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     public static <T> Pointer getReferentPointer(Reference<T> instance) {
         return Word.objectToUntrackedPointer(ObjectAccess.readObject(instance, WordFactory.signed(Target_java_lang_ref_Reference.referentFieldOffset)));
     }
@@ -79,7 +80,7 @@ public final class ReferenceInternals {
     }
 
     /** Write {@link Target_java_lang_ref_Reference#referent}. */
-    @SuppressWarnings("unchecked")
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     public static void setReferent(Reference<?> instance, Object value) {
         BarrieredAccess.writeObject(instance, WordFactory.signed(Target_java_lang_ref_Reference.referentFieldOffset), value);
     }
@@ -105,6 +106,7 @@ public final class ReferenceInternals {
         ObjectAccess.writeObject(instance, WordFactory.signed(Target_java_lang_ref_Reference.referentFieldOffset), null);
     }
 
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     public static <T> Pointer getReferentFieldAddress(Reference<T> instance) {
         return Word.objectToUntrackedPointer(instance).add(WordFactory.unsigned(Target_java_lang_ref_Reference.referentFieldOffset));
     }
@@ -119,6 +121,7 @@ public final class ReferenceInternals {
     }
 
     /** Barrier-less read of {@link Target_java_lang_ref_Reference#discovered} as a pointer. */
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     public static <T> Pointer getDiscoveredPointer(Reference<T> instance) {
         return Word.objectToUntrackedPointer(ObjectAccess.readObject(instance, WordFactory.signed(Target_java_lang_ref_Reference.discoveredFieldOffset)));
     }
@@ -140,6 +143,7 @@ public final class ReferenceInternals {
     }
 
     /** Write {@link Target_java_lang_ref_Reference#discovered}. */
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     public static <T> void setNextDiscovered(Reference<T> instance, Reference<?> newNext) {
         BarrieredAccess.writeObject(instance, WordFactory.signed(Target_java_lang_ref_Reference.discoveredFieldOffset), newNext);
     }
@@ -251,6 +255,7 @@ public final class ReferenceInternals {
         }
     }
 
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     public static long getSoftReferenceClock() {
         return Target_java_lang_ref_SoftReference.clock;
     }
@@ -262,6 +267,7 @@ public final class ReferenceInternals {
         }
     }
 
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     public static long getSoftReferenceTimestamp(SoftReference<?> instance) {
         Target_java_lang_ref_SoftReference<?> ref = SubstrateUtil.cast(instance, Target_java_lang_ref_SoftReference.class);
         return ref.timestamp;
diff --git a/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/heap/ReferenceMapIndex.java b/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/heap/ReferenceMapIndex.java
index 4989c633cbb..e80b89687ee 100644
--- a/graal/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/heap/ReferenceMapIndex.java
+++ b/graal/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/heap/ReferenceMapIndex.java
@@ -24,6 +24,8 @@
  */
 package com.oracle.svm.core.heap;
 
+import com.oracle.svm.core.Uninterruptible;
+
 public class ReferenceMapIndex {
     /**
      * Marker value returned by
@@ -44,6 +46,7 @@ public class ReferenceMapIndex {
         return referenceMapIndex == EMPTY_REFERENCE_MAP || referenceMapIndex == NO_REFERENCE_MAP;
     }
 
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     public static boolean denotesValidReferenceMap(long referenceMapIndex) {
         return referenceMapIndex != NO_REFERENCE_MAP;
     }
diff --git a/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/heap/Target_java_lang_ref_Reference.java b/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/heap/Target_java_lang_ref_Reference.java
index ae43c62f9f2..da17b8e8f99 100644
--- a/graal/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/heap/Target_java_lang_ref_Reference.java
+++ b/graal/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/heap/Target_java_lang_ref_Reference.java
@@ -101,7 +101,7 @@ public final class Target_java_lang_ref_Reference<T> {
 
     @SuppressWarnings("unused") //
     @Alias @RecomputeFieldValue(kind = RecomputeFieldValue.Kind.Reset) //
-    @ExcludeFromReferenceMap(reason = "Some GCs process this field manually.", onlyIf = NotSerialNotEpsilonGC.class) //
+    @ExcludeFromReferenceMap(reason = "Some GCs process this field manually.", onlyIf = NotSerialNotParallelNotEpsilonGC.class) //
     transient Target_java_lang_ref_Reference<?> discovered;
 
     @Alias @RecomputeFieldValue(kind = RecomputeFieldValue.Kind.Custom, declClass = ComputeQueueValue.class) //
@@ -235,9 +235,9 @@ class ComputeQueueValue implements FieldValueTransformer {
 }
 
 @Platforms(Platform.HOSTED_ONLY.class)
-class NotSerialNotEpsilonGC implements BooleanSupplier {
+class NotSerialNotParallelNotEpsilonGC implements BooleanSupplier {
     @Override
     public boolean getAsBoolean() {
-        return !SubstrateOptions.UseSerialGC.getValue() && !SubstrateOptions.UseEpsilonGC.getValue();
+        return !SubstrateOptions.useSerialOrParallelOrEpsilonGC();
     }
 }
diff --git a/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/hub/DynamicHub.java b/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/hub/DynamicHub.java
index 856d12a7aa0..a179837c6be 100644
--- a/graal/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/hub/DynamicHub.java
+++ b/graal/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/hub/DynamicHub.java
@@ -638,6 +638,7 @@ public final class DynamicHub implements AnnotatedElement, java.lang.reflect.Typ
         return arrayHub;
     }
 
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     public int getReferenceMapIndex() {
         return referenceMapIndex;
     }
@@ -682,6 +683,7 @@ public final class DynamicHub implements AnnotatedElement, java.lang.reflect.Typ
         return name;
     }
 
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     public int getHubType() {
         return hubType;
     }
diff --git a/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/hub/InteriorObjRefWalker.java b/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/hub/InteriorObjRefWalker.java
index fe2a8f6c450..989fad267fa 100644
--- a/graal/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/hub/InteriorObjRefWalker.java
+++ b/graal/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/hub/InteriorObjRefWalker.java
@@ -33,6 +33,7 @@ import org.graalvm.word.WordFactory;
 
 import com.oracle.svm.core.AlwaysInline;
 import com.oracle.svm.core.NeverInline;
+import com.oracle.svm.core.Uninterruptible;
 import com.oracle.svm.core.c.NonmovableArray;
 import com.oracle.svm.core.config.ConfigurationValues;
 import com.oracle.svm.core.heap.InstanceReferenceMapDecoder;
@@ -66,6 +67,7 @@ public class InteriorObjRefWalker {
     }
 
     @AlwaysInline("Performance critical version")
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     public static boolean walkObjectInline(final Object obj, final ObjectReferenceVisitor visitor) {
         final DynamicHub objHub = ObjectHeader.readDynamicHubFromObject(obj);
         final Pointer objPointer = Word.objectToUntrackedPointer(obj);
@@ -107,6 +109,7 @@ public class InteriorObjRefWalker {
     }
 
     @AlwaysInline("Performance critical version")
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     private static boolean walkInstance(Object obj, ObjectReferenceVisitor visitor, DynamicHub objHub, Pointer objPointer) {
         NonmovableArray<Byte> referenceMapEncoding = DynamicHubSupport.getReferenceMapEncoding();
         long referenceMapIndex = objHub.getReferenceMapIndex();
@@ -116,6 +119,7 @@ public class InteriorObjRefWalker {
     }
 
     @AlwaysInline("Performance critical version")
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     private static boolean walkPod(Object obj, ObjectReferenceVisitor visitor, DynamicHub objHub, Pointer objPointer) {
         if (!Pod.RuntimeSupport.isPresent()) {
             throw VMError.shouldNotReachHere("Pod objects cannot be in the heap if the pod support is disabled.");
@@ -124,6 +128,7 @@ public class InteriorObjRefWalker {
     }
 
     @AlwaysInline("Performance critical version")
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     private static boolean walkStoredContinuation(Object obj, ObjectReferenceVisitor visitor) {
         if (!Continuation.isSupported()) {
             throw VMError.shouldNotReachHere("Stored continuation objects cannot be in the heap if the continuation support is disabled.");
@@ -132,11 +137,13 @@ public class InteriorObjRefWalker {
     }
 
     @AlwaysInline("Performance critical version")
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     private static boolean walkOther() {
         throw VMError.shouldNotReachHere("Unexpected object with hub type 'other' in the heap.");
     }
 
     @AlwaysInline("Performance critical version")
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     private static boolean walkObjectArray(Object obj, ObjectReferenceVisitor visitor, DynamicHub objHub, Pointer objPointer) {
         int length = ArrayLengthNode.arrayLength(obj);
         int referenceSize = ConfigurationValues.getObjectLayout().getReferenceSize();
@@ -145,7 +152,7 @@ public class InteriorObjRefWalker {
         Pointer pos = objPointer.add(LayoutEncoding.getArrayBaseOffset(objHub.getLayoutEncoding()));
         Pointer end = pos.add(WordFactory.unsigned(referenceSize).multiply(length));
         while (pos.belowThan(end)) {
-            final boolean visitResult = visitor.visitObjectReferenceInline(pos, 0, isCompressed, obj);
+            final boolean visitResult = callVisitor(obj, visitor, isCompressed, pos);
             if (!visitResult) {
                 return false;
             }
@@ -153,4 +160,9 @@ public class InteriorObjRefWalker {
         }
         return true;
     }
+
+    @Uninterruptible(reason = "Bridge between uninterruptible and potentially interruptible code.", mayBeInlined = true, calleeMustBe = false)
+    private static boolean callVisitor(Object obj, ObjectReferenceVisitor visitor, boolean isCompressed, Pointer pos) {
+        return visitor.visitObjectReferenceInline(pos, 0, isCompressed, obj);
+    }
 }
diff --git a/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/hub/LayoutEncoding.java b/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/hub/LayoutEncoding.java
index 1e63276c3a3..2af175db213 100644
--- a/graal/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/hub/LayoutEncoding.java
+++ b/graal/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/hub/LayoutEncoding.java
@@ -329,27 +329,69 @@ public class LayoutEncoding {
         return getSizeFromObject(obj);
     }
 
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     public static UnsignedWord getSizeFromObjectInGC(Object obj) {
         return getSizeFromObjectInlineInGC(obj);
     }
 
     @AlwaysInline("GC performance")
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     public static UnsignedWord getSizeFromObjectInlineInGC(Object obj) {
         return getSizeFromObjectInlineInGC(obj, false);
     }
 
     @AlwaysInline("GC performance")
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     public static UnsignedWord getSizeFromObjectInlineInGC(Object obj, boolean addOptionalIdHashField) {
         boolean withOptionalIdHashField = addOptionalIdHashField ||
                         (!ConfigurationValues.getObjectLayout().hasFixedIdentityHashField() && checkOptionalIdentityHashField(obj));
         return getSizeFromObjectInline(obj, withOptionalIdHashField);
     }
 
+    @AlwaysInline("GC performance")
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
+    public static UnsignedWord getSizeFromHeader(Object obj, Word header, long eightHeaderBytes, boolean addOptionalIdHashField) {
+        ObjectHeader oh = Heap.getHeap().getObjectHeader();
+        DynamicHub hub = oh.dynamicHubFromObjectHeader(header);
+        int encoding = hub.getLayoutEncoding();
+        boolean withOptionalIdHashField = addOptionalIdHashField ||
+                        (!ConfigurationValues.getObjectLayout().hasFixedIdentityHashField() && oh.hasOptionalIdentityHashField(header));
+
+        if (isArrayLike(encoding)) {
+            int arrayLength = getArrayLengthFromHeader(obj, eightHeaderBytes);
+            return getArraySize(encoding, arrayLength, withOptionalIdHashField);
+        } else {
+            return getPureInstanceSize(hub, withOptionalIdHashField);
+        }
+    }
+
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
+    private static int getArrayLengthFromHeader(Object obj, long eightHeaderBytes) {
+        ObjectLayout ol = ConfigurationValues.getObjectLayout();
+        assert ol.getArrayLengthOffset() >= 4;
+        if (ol.getArrayLengthOffset() == 4) {
+            /*
+             * If the array length is located within the first 8 bytes, then we need to extract it
+             * from the already read header data.
+             */
+            int result = (int) (eightHeaderBytes >>> 32);
+            assert result >= 0;
+            return result;
+        }
+        return ArrayLengthNode.arrayLength(obj);
+    }
+
     @AlwaysInline("Actual inlining decided by callers.")
     @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     private static UnsignedWord getSizeFromObjectInline(Object obj, boolean withOptionalIdHashField) {
         DynamicHub hub = KnownIntrinsics.readHub(obj);
         int encoding = hub.getLayoutEncoding();
+        return getSizeFromEncoding(obj, hub, encoding, withOptionalIdHashField);
+    }
+
+    @AlwaysInline("GC performance")
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
+    private static UnsignedWord getSizeFromEncoding(Object obj, DynamicHub hub, int encoding, boolean withOptionalIdHashField) {
         if (isArrayLike(encoding)) {
             return getArraySize(encoding, ArrayLengthNode.arrayLength(obj), withOptionalIdHashField);
         } else {
@@ -365,11 +407,13 @@ public class LayoutEncoding {
         return oh.hasOptionalIdentityHashField(header);
     }
 
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     public static Pointer getObjectEndInGC(Object obj) {
         return getObjectEndInlineInGC(obj);
     }
 
     @AlwaysInline("GC performance")
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     public static Pointer getObjectEndInlineInGC(Object obj) {
         UnsignedWord size = getSizeFromObjectInlineInGC(obj, false);
         return Word.objectToUntrackedPointer(obj).add(size);
diff --git a/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/identityhashcode/IdentityHashCodeSupport.java b/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/identityhashcode/IdentityHashCodeSupport.java
index 32ffd958556..edebb2f74d1 100644
--- a/graal/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/identityhashcode/IdentityHashCodeSupport.java
+++ b/graal/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/identityhashcode/IdentityHashCodeSupport.java
@@ -85,8 +85,12 @@ public final class IdentityHashCodeSupport {
 
     @Uninterruptible(reason = "Prevent a GC interfering with the object's identity hash state.")
     public static int computeHashCodeFromAddress(Object obj) {
-        Word address = Word.objectToUntrackedPointer(obj);
         long salt = Heap.getHeap().getIdentityHashSalt(obj);
+        return computeHashCodeFromAddress(Word.objectToUntrackedPointer(obj), salt);
+    }
+
+    @Uninterruptible(reason = "Prevent a GC interfering with the object's identity hash state.")
+    public static int computeHashCodeFromAddress(Word address, long salt) {
         SignedWord salted = WordFactory.signed(salt).xor(address);
         int hash = mix32(salted.rawValue()) >>> 1; // shift: ensure positive, same as on HotSpot
         return (hash == 0) ? 1 : hash; // ensure nonzero
diff --git a/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/jdk/UninterruptibleUtils.java b/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/jdk/UninterruptibleUtils.java
index edb8c09bb17..143954b7ed1 100644
--- a/graal/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/jdk/UninterruptibleUtils.java
+++ b/graal/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/jdk/UninterruptibleUtils.java
@@ -435,6 +435,14 @@ public class UninterruptibleUtils {
         }
     }
 
+    public static class Byte {
+        @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
+        @SuppressWarnings("cast")
+        public static int toUnsignedInt(byte x) {
+            return ((int) x) & 0xff;
+        }
+    }
+
     public static class Long {
         /** Uninterruptible version of {@link java.lang.Long#numberOfLeadingZeros(long)}. */
         @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
diff --git a/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/jdk/VMErrorSubstitutions.java b/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/jdk/VMErrorSubstitutions.java
index 5a5e6c2e91a..1917736e040 100644
--- a/graal/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/jdk/VMErrorSubstitutions.java
+++ b/graal/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/jdk/VMErrorSubstitutions.java
@@ -27,7 +27,9 @@ package com.oracle.svm.core.jdk;
 import static com.oracle.svm.core.heap.RestrictHeapAccess.Access.NO_ALLOCATION;
 
 import org.graalvm.compiler.nodes.UnreachableNode;
+import org.graalvm.nativeimage.CurrentIsolate;
 import org.graalvm.nativeimage.ImageSingletons;
+import org.graalvm.nativeimage.Isolate;
 import org.graalvm.nativeimage.LogHandler;
 import org.graalvm.nativeimage.Platforms;
 import org.graalvm.nativeimage.c.function.CodePointer;
@@ -35,9 +37,11 @@ import org.graalvm.nativeimage.impl.InternalPlatform;
 
 import com.oracle.svm.core.NeverInline;
 import com.oracle.svm.core.SubstrateDiagnostics;
+import com.oracle.svm.core.SubstrateOptions;
 import com.oracle.svm.core.Uninterruptible;
 import com.oracle.svm.core.annotate.Substitute;
 import com.oracle.svm.core.annotate.TargetClass;
+import com.oracle.svm.core.c.function.CEntryPointActions;
 import com.oracle.svm.core.heap.RestrictHeapAccess;
 import com.oracle.svm.core.log.Log;
 import com.oracle.svm.core.snippets.KnownIntrinsics;
@@ -106,6 +110,10 @@ public class VMErrorSubstitutions {
     static RuntimeException shouldNotReachHere(CodePointer callerIP, String msg, Throwable ex) {
         ThreadStackPrinter.printBacktrace();
 
+        if (SubstrateOptions.SpawnIsolates.getValue() && CurrentIsolate.getCurrentThread().isNull()) {
+            CEntryPointActions.enterAttachThreadFromCrashHandler((Isolate) KnownIntrinsics.heapBase());
+        }
+
         SafepointBehavior.preventSafepoints();
         StackOverflowCheck.singleton().disableStackOverflowChecksForFatalError();
 
diff --git a/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/locks/SingleThreadedVMLockSupport.java b/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/locks/SingleThreadedVMLockSupport.java
index e20eafb49af..f048ec19f3a 100644
--- a/graal/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/locks/SingleThreadedVMLockSupport.java
+++ b/graal/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/locks/SingleThreadedVMLockSupport.java
@@ -177,6 +177,7 @@ final class SingleThreadedVMCondition extends VMCondition {
     }
 
     @Override
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     public void signal() {
         /* Nothing to do. */
     }
diff --git a/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/locks/VMCondition.java b/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/locks/VMCondition.java
index 6a587217130..f85d789026d 100644
--- a/graal/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/locks/VMCondition.java
+++ b/graal/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/locks/VMCondition.java
@@ -98,6 +98,7 @@ public class VMCondition {
     /**
      * Wakes up a single thread that is waiting on this condition.
      */
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     public void signal() {
         throw VMError.shouldNotReachHere("VMCondition cannot be used during native image generation");
     }
diff --git a/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/locks/VMMutex.java b/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/locks/VMMutex.java
index 6a4504de544..c9e316bd226 100644
--- a/graal/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/locks/VMMutex.java
+++ b/graal/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/locks/VMMutex.java
@@ -174,6 +174,11 @@ public class VMMutex {
         return owner == CurrentIsolate.getCurrentThread();
     }
 
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
+    public final boolean isOwner(boolean allowUnspecifiedOwner) {
+        return owner == CurrentIsolate.getCurrentThread() || (allowUnspecifiedOwner && hasUnspecifiedOwner());
+    }
+
     @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     public void setOwnerToCurrentThread() {
         assertIsNotLocked("The owner can only be set if no other thread holds the mutex.");
@@ -203,4 +208,13 @@ public class VMMutex {
     public boolean hasOwner() {
         return owner.isNonNull();
     }
+
+    /**
+     * This method is potentially racy and must only be called in places where we can guarantee that
+     * no incorrect {@link AssertionError}s are thrown because of potential races.
+     */
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
+    private boolean hasUnspecifiedOwner() {
+        return owner == (IsolateThread) UNSPECIFIED_OWNER;
+    }
 }
diff --git a/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/os/AbstractCommittedMemoryProvider.java b/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/os/AbstractCommittedMemoryProvider.java
index 59caeb9d837..54e056a7d67 100644
--- a/graal/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/os/AbstractCommittedMemoryProvider.java
+++ b/graal/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/os/AbstractCommittedMemoryProvider.java
@@ -82,6 +82,7 @@ public abstract class AbstractCommittedMemoryProvider implements CommittedMemory
     }
 
     @Override
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     public Pointer allocateAlignedChunk(UnsignedWord nbytes, UnsignedWord alignment) {
         return allocate(nbytes, alignment, false);
     }
diff --git a/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/os/CommittedMemoryProvider.java b/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/os/CommittedMemoryProvider.java
index 7b9e47d715f..12c6b28d535 100644
--- a/graal/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/os/CommittedMemoryProvider.java
+++ b/graal/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/os/CommittedMemoryProvider.java
@@ -80,6 +80,7 @@ public interface CommittedMemoryProvider {
         return VirtualMemoryProvider.get().getGranularity();
     }
 
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     Pointer allocateAlignedChunk(UnsignedWord nbytes, UnsignedWord alignment);
 
     Pointer allocateUnalignedChunk(UnsignedWord nbytes);
diff --git a/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/sampler/SubstrateSigprofHandler.java b/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/sampler/SubstrateSigprofHandler.java
index 6a3ce192bc0..7881f779b64 100644
--- a/graal/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/sampler/SubstrateSigprofHandler.java
+++ b/graal/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/sampler/SubstrateSigprofHandler.java
@@ -32,7 +32,6 @@ import org.graalvm.nativeimage.IsolateThread;
 import org.graalvm.nativeimage.Platform;
 import org.graalvm.nativeimage.Platforms;
 import org.graalvm.word.Pointer;
-import org.graalvm.word.UnsignedWord;
 import org.graalvm.word.WordFactory;
 
 import com.oracle.svm.core.IsolateListenerSupport.IsolateListener;
@@ -44,6 +43,8 @@ import com.oracle.svm.core.graal.nodes.WriteCurrentVMThreadNode;
 import com.oracle.svm.core.graal.nodes.WriteHeapBaseNode;
 import com.oracle.svm.core.jfr.SubstrateJVM;
 import com.oracle.svm.core.jfr.sampler.AbstractJfrExecutionSampler;
+import com.oracle.svm.core.thread.PlatformThreads;
+import com.oracle.svm.core.thread.PlatformThreads.ThreadLocalKey;
 import com.oracle.svm.core.thread.ThreadListener;
 import com.oracle.svm.core.thread.VMOperation;
 import com.oracle.svm.core.thread.VMThreads;
@@ -61,7 +62,7 @@ import com.oracle.svm.core.thread.VMThreads;
  */
 public abstract class SubstrateSigprofHandler extends AbstractJfrExecutionSampler implements IsolateListener, ThreadListener {
     private static final CGlobalData<Pointer> SIGNAL_HANDLER_ISOLATE = CGlobalDataFactory.createWord();
-    private UnsignedWord keyForNativeThreadLocal;
+    private ThreadLocalKey keyForNativeThreadLocal;
 
     @Platforms(Platform.HOSTED_ONLY.class)
     protected SubstrateSigprofHandler() {
@@ -75,15 +76,15 @@ public abstract class SubstrateSigprofHandler extends AbstractJfrExecutionSample
     @Override
     @Uninterruptible(reason = "Thread state not set up yet.")
     public void afterCreateIsolate(Isolate isolate) {
-        keyForNativeThreadLocal = createNativeThreadLocal();
+        keyForNativeThreadLocal = PlatformThreads.singleton().createUnmanagedThreadLocal();
     }
 
     @Override
     @Uninterruptible(reason = "The isolate teardown is in progress.")
     public void onIsolateTeardown() {
-        UnsignedWord oldKey = keyForNativeThreadLocal;
+        ThreadLocalKey oldKey = keyForNativeThreadLocal;
         keyForNativeThreadLocal = WordFactory.nullPointer();
-        deleteNativeThreadLocal(oldKey);
+        PlatformThreads.singleton().deleteUnmanagedThreadLocal(oldKey);
     }
 
     @Override
@@ -175,18 +176,6 @@ public abstract class SubstrateSigprofHandler extends AbstractJfrExecutionSample
         }
     }
 
-    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
-    protected abstract UnsignedWord createNativeThreadLocal();
-
-    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
-    protected abstract void deleteNativeThreadLocal(UnsignedWord key);
-
-    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
-    protected abstract void setNativeThreadLocalValue(UnsignedWord key, IsolateThread value);
-
-    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
-    protected abstract IsolateThread getNativeThreadLocalValue(UnsignedWord key);
-
     /**
      * Called from the platform dependent sigprof handler to enter isolate.
      */
@@ -205,8 +194,8 @@ public abstract class SubstrateSigprofHandler extends AbstractJfrExecutionSample
 
         /* We are keeping reference to isolate thread inside OS thread local area. */
         if (SubstrateOptions.MultiThreaded.getValue()) {
-            UnsignedWord key = singleton().keyForNativeThreadLocal;
-            IsolateThread thread = singleton().getNativeThreadLocalValue(key);
+            ThreadLocalKey key = singleton().keyForNativeThreadLocal;
+            IsolateThread thread = PlatformThreads.singleton().getUnmanagedThreadLocalValue(key);
             if (thread.isNull()) {
                 /* Thread is not yet initialized or already detached from isolate. */
                 return false;
@@ -220,6 +209,6 @@ public abstract class SubstrateSigprofHandler extends AbstractJfrExecutionSample
 
     @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     private void storeIsolateThreadInNativeThreadLocal(IsolateThread isolateThread) {
-        setNativeThreadLocalValue(keyForNativeThreadLocal, isolateThread);
+        PlatformThreads.singleton().setUnmanagedThreadLocalValue(keyForNativeThreadLocal, isolateThread);
     }
 }
diff --git a/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/thread/PlatformThreads.java b/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/thread/PlatformThreads.java
index 98ac6816851..ed39624c9a7 100644
--- a/graal/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/thread/PlatformThreads.java
+++ b/graal/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/thread/PlatformThreads.java
@@ -66,9 +66,11 @@ import org.graalvm.nativeimage.c.function.CEntryPoint;
 import org.graalvm.nativeimage.c.function.CEntryPointLiteral;
 import org.graalvm.nativeimage.c.function.CFunctionPointer;
 import org.graalvm.nativeimage.c.struct.RawField;
+import org.graalvm.nativeimage.c.struct.RawPointerTo;
 import org.graalvm.nativeimage.c.struct.RawStructure;
 import org.graalvm.nativeimage.c.type.CCharPointer;
 import org.graalvm.nativeimage.c.type.WordPointer;
+import org.graalvm.word.ComparableWord;
 import org.graalvm.word.Pointer;
 import org.graalvm.word.PointerBase;
 import org.graalvm.word.WordBase;
@@ -578,12 +580,40 @@ public abstract class PlatformThreads {
         throw VMError.shouldNotReachHere("Shouldn't call PlatformThreads.startThreadUnmanaged directly.");
     }
 
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
+    public boolean joinThreadUnmanaged(OSThreadHandle threadHandle) {
+        return joinThreadUnmanaged(threadHandle, WordFactory.nullPointer());
+    }
+
     @SuppressWarnings("unused")
     @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     public boolean joinThreadUnmanaged(OSThreadHandle threadHandle, WordPointer threadExitStatus) {
         throw VMError.shouldNotReachHere("Shouldn't call PlatformThreads.joinThreadUnmanaged directly.");
     }
 
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
+    public ThreadLocalKey createUnmanagedThreadLocal() {
+        throw VMError.shouldNotReachHere("Shouldn't call PlatformThreads.createNativeThreadLocal directly.");
+    }
+
+    @SuppressWarnings("unused")
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
+    public void deleteUnmanagedThreadLocal(ThreadLocalKey key) {
+        throw VMError.shouldNotReachHere("Shouldn't call PlatformThreads.deleteNativeThreadLocal directly.");
+    }
+
+    @SuppressWarnings("unused")
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
+    public <T extends WordBase> T getUnmanagedThreadLocalValue(ThreadLocalKey key) {
+        throw VMError.shouldNotReachHere("Shouldn't call PlatformThreads.getNativeThreadLocalValue directly.");
+    }
+
+    @SuppressWarnings("unused")
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
+    public void setUnmanagedThreadLocalValue(ThreadLocalKey key, WordBase value) {
+        throw VMError.shouldNotReachHere("Shouldn't call PlatformThreads.setNativeThreadLocalValue directly.");
+    }
+
     @SuppressWarnings("unused")
     @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     public void closeOSThreadHandle(OSThreadHandle threadHandle) {
@@ -1285,6 +1315,16 @@ public abstract class PlatformThreads {
             }
         }
     }
+
+    @RawPointerTo(OSThreadHandle.class)
+    public interface OSThreadHandlePointer extends PointerBase {
+        void write(int index, OSThreadHandle value);
+
+        OSThreadHandle read(int index);
+    }
+
+    public interface ThreadLocalKey extends ComparableWord {
+    }
 }
 
 @TargetClass(value = ThreadPoolExecutor.class, innerClass = "Worker")
diff --git a/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/thread/VMThreads.java b/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/thread/VMThreads.java
index 769f5698376..c90a24956a4 100644
--- a/graal/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/thread/VMThreads.java
+++ b/graal/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/thread/VMThreads.java
@@ -34,6 +34,7 @@ import org.graalvm.nativeimage.Isolate;
 import org.graalvm.nativeimage.IsolateThread;
 import org.graalvm.nativeimage.c.function.CFunction;
 import org.graalvm.nativeimage.c.function.CodePointer;
+import org.graalvm.nativeimage.c.struct.RawStructure;
 import org.graalvm.nativeimage.c.type.CCharPointer;
 import org.graalvm.nativeimage.impl.UnmanagedMemorySupport;
 import org.graalvm.word.Pointer;
@@ -617,6 +618,11 @@ public abstract class VMThreads {
         return THREAD_MUTEX.isOwner();
     }
 
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
+    public static boolean ownsThreadMutex(boolean allowUnspecifiedOwner) {
+        return THREAD_MUTEX.isOwner(allowUnspecifiedOwner);
+    }
+
     public static boolean printLocationInfo(Log log, UnsignedWord value, boolean allowUnsafeOperations) {
         if (!allowUnsafeOperations && !VMOperation.isInProgressAtSafepoint()) {
             /*
@@ -1050,6 +1056,7 @@ public abstract class VMThreads {
         }
     }
 
+    @RawStructure
     public interface OSThreadHandle extends PointerBase {
     }
 
diff --git a/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/threadlocal/VMThreadLocalMTSupport.java b/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/threadlocal/VMThreadLocalMTSupport.java
index bb192cc5a5b..874bd588bc1 100644
--- a/graal/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/threadlocal/VMThreadLocalMTSupport.java
+++ b/graal/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/threadlocal/VMThreadLocalMTSupport.java
@@ -67,6 +67,7 @@ public class VMThreadLocalMTSupport {
         return (int) result;
     }
 
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     public void walk(IsolateThread isolateThread, ObjectReferenceVisitor referenceVisitor) {
         NonmovableArray<Byte> threadRefMapEncoding = NonmovableArrays.fromImageHeap(vmThreadReferenceMapEncoding);
         InstanceReferenceMapDecoder.walkOffsetsFromPointer((Pointer) isolateThread, threadRefMapEncoding, vmThreadReferenceMapIndex, referenceVisitor, null);
diff --git a/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/util/TypedMemoryReader.java b/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/util/TypedMemoryReader.java
index 22f004c74e2..f3881ad6048 100644
--- a/graal/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/util/TypedMemoryReader.java
+++ b/graal/substratevm/src/com.oracle.svm.core/src/com/oracle/svm/core/util/TypedMemoryReader.java
@@ -24,33 +24,41 @@
  */
 package com.oracle.svm.core.util;
 
+import com.oracle.svm.core.Uninterruptible;
 import org.graalvm.word.Pointer;
 
 public class TypedMemoryReader {
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     public static int getS1(Pointer ptr) {
         return ptr.readByte(0);
     }
 
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     public static int getS2(Pointer ptr) {
         return ptr.readShort(0);
     }
 
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     public static int getS4(Pointer ptr) {
         return ptr.readInt(0);
     }
 
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     public static long getS8(Pointer ptr) {
         return ptr.readLong(0);
     }
 
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     public static int getU1(Pointer ptr) {
         return getS1(ptr) & 0xFF;
     }
 
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     public static int getU2(Pointer ptr) {
         return getS2(ptr) & 0xFFFF;
     }
 
+    @Uninterruptible(reason = "Called from uninterruptible code.", mayBeInlined = true)
     public static long getU4(Pointer ptr) {
         return getS4(ptr) & 0xFFFFFFFFL;
     }
diff --git a/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/code/UninterruptibleAnnotationChecker.java b/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/code/UninterruptibleAnnotationChecker.java
index c372b8e1591..15e58be1f46 100644
--- a/graal/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/code/UninterruptibleAnnotationChecker.java
+++ b/graal/substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/code/UninterruptibleAnnotationChecker.java
@@ -45,6 +45,7 @@ import com.oracle.svm.core.AlwaysInline;
 import com.oracle.svm.core.NeverInline;
 import com.oracle.svm.core.SubstrateOptions;
 import com.oracle.svm.core.Uninterruptible;
+import com.oracle.svm.core.classinitialization.EnsureClassInitializedNode;
 import com.oracle.svm.core.feature.AutomaticallyRegisteredImageSingleton;
 import com.oracle.svm.core.option.HostedOptionKey;
 import com.oracle.svm.core.os.RawFileOperationSupport;
@@ -73,8 +74,7 @@ public final class UninterruptibleAnnotationChecker {
 
     public static void checkAfterParsing(ResolvedJavaMethod method, StructuredGraph graph) {
         if (Uninterruptible.Utils.isUninterruptible(method) && graph != null) {
-            singleton().checkNoAllocation(method, graph);
-            singleton().checkNoSynchronization(method, graph);
+            singleton().checkGraph(method, graph);
         }
     }
 
@@ -134,12 +134,6 @@ public final class UninterruptibleAnnotationChecker {
         }
 
         if (annotation.mayBeInlined()) {
-            if (!annotation.reason().equals(Uninterruptible.CALLED_FROM_UNINTERRUPTIBLE_CODE) && !AnnotationAccess.isAnnotationPresent(method, AlwaysInline.class)) {
-                violations.add("Method " + method.format("%H.%n(%p)") + " is annotated with @Uninterruptible('mayBeInlined = true') which allows the method to be inlined into interruptible code. " +
-                                "If the method has an inherent reason for being uninterruptible, besides being called from uninterruptible code, then please remove 'mayBeInlined = true'. " +
-                                "Otherwise, use the following reason: '" + Uninterruptible.CALLED_FROM_UNINTERRUPTIBLE_CODE + "'");
-            }
-
             if (AnnotationAccess.isAnnotationPresent(method, NeverInline.class)) {
                 violations.add("Method " + method.format("%H.%n(%p)") +
                                 " is annotated with conflicting annotations: @Uninterruptible('mayBeInlined = true') and @NeverInline");
@@ -151,6 +145,14 @@ public final class UninterruptibleAnnotationChecker {
             }
         }
 
+        if (annotation.mayBeInlined() && annotation.calleeMustBe()) {
+            if (!annotation.reason().equals(Uninterruptible.CALLED_FROM_UNINTERRUPTIBLE_CODE) && !AnnotationAccess.isAnnotationPresent(method, AlwaysInline.class)) {
+                violations.add("Method " + method.format("%H.%n(%p)") + " is annotated with @Uninterruptible('mayBeInlined = true') which allows the method to be inlined into interruptible code. " +
+                                "If the method has an inherent reason for being uninterruptible, besides being called from uninterruptible code, then please remove 'mayBeInlined = true'. " +
+                                "Otherwise, use the following reason: '" + Uninterruptible.CALLED_FROM_UNINTERRUPTIBLE_CODE + "'");
+            }
+        }
+
         if (!annotation.mayBeInlined() && !annotation.callerMustBe() && AnnotationAccess.isAnnotationPresent(method, AlwaysInline.class)) {
             violations.add("Method " + method.format("%H.%n(%p)") +
                             " is annotated with @Uninterruptible and @AlwaysInline. If the method may be inlined into interruptible code, please specify 'mayBeInlined = true'. Otherwise, specify 'callerMustBe = true'.");
@@ -259,18 +261,14 @@ public final class UninterruptibleAnnotationChecker {
         }
     }
 
-    private void checkNoAllocation(ResolvedJavaMethod method, StructuredGraph graph) {
+    private void checkGraph(ResolvedJavaMethod method, StructuredGraph graph) {
         for (Node node : graph.getNodes()) {
             if (isAllocationNode(node)) {
                 violations.add("Uninterruptible method " + method.format("%H.%n(%p)") + " is not allowed to allocate.");
-            }
-        }
-    }
-
-    private void checkNoSynchronization(ResolvedJavaMethod method, StructuredGraph graph) {
-        for (Node node : graph.getNodes()) {
-            if (node instanceof MonitorEnterNode) {
+            } else if (node instanceof MonitorEnterNode) {
                 violations.add("Uninterruptible method " + method.format("%H.%n(%p)") + " is not allowed to use 'synchronized'.");
+            } else if (node instanceof EnsureClassInitializedNode) {
+                violations.add("Uninterruptible method " + method.format("%H.%n(%p)") + " not allowed to do class initialization.");
             }
         }
     }
